local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Lighting = game:GetService("Lighting")
local VirtualUser = game:GetService("VirtualUser")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProximityPromptService = game:GetService("ProximityPromptService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local SoundService = game:GetService("SoundService")
local Debris = game:GetService("Debris")

local notifysound = 4590657391

local PlayingSound = true
local promptReachMultiplier = 2.0

function Sound()

local sound = Instance.new("Sound",SoundService)

sound.Volume = 2.5

sound.SoundId = "rbxassetid://" .. notifysound 

sound.Playing = PlayingSound and true or false

Debris:AddItem(sound,2)

end
Sound()

function WaitForChildOfClass(Parent , Part)

local Clas = Parent:FindFirstChildOfClass(Part)
while Clas == nil do
task.wait()
Clas = Parent.DescendantAdded:Wait()
if Clas:IsA(Part) then
return Clas
end
end
return Clas

end

if LocalPlayer:GetAttribute("StarringLoaded") then 
print("StarRingÂáÜÂ§áÂä†ËΩΩ")

return end

if game:GetService("ReplicatedStorage"):FindFirstChild("RemotesFolder") then

repeat task.wait() until workspace.CurrentRooms:FindFirstChildOfClass("Model")

local Disable1 = false
local Disable2 = false
local Disable3 = false
local Disable4 = false
local Disable5 = false
local FakeSurge
local alive 
local Pathnode 

local repo
if UIStyle == "LinoriaLib" then
repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
else
repo = 'https://raw.githubusercontent.com/mstudio45/Obsidian/main/'
end
local Executor = identifyexecutor() or getexecutorname() or "Unknown"
local Library = loadstring(game:HttpGet(repo..'Library.lua'))()

Window = Library:CreateWindow({
Title = 'üí† StarRing V3',
Footer = "QQÁæ§1070767561",
Center = true,
NotifySide = "Right",
AutoShow = true
})

if KEY ~= "FREE_Áæ§1070767561" then
Library:Notify("Âç°ÂØÜÈîôËØØÔºåËé∑ÂèñÂç°ÂØÜÂä†ÂÖ•QQÁæ§<font color=\"rgb(135,206,250)\">1070767561</font>", 20)
return
end

Library.ForceCheckbox = true

Library:Notify("Ê≠£Âú®Âä†ËΩΩ StarRing | Doors",5)

if Executor == "Xeno" or Executor == "xeno" then Library:Notify("Ê≥®ÂÖ•Âô®‰∏çÊîØÊåÅÂêØÂä®",3) return end

local success, result = pcall(function()
return RequiredMainGame
end)
if not success then
Disable1 = true
print("false require")
end

print("true require")
 
if not isnetworkowner then
Disable2 = true
print("false isnetworkowner")
end

print("true isnetworkowner")
local Prompt = Instance.new("ProximityPrompt",workspace)
Prompt.Name = "TestPrompt"

local success, result = pcall(function()
return fireproximityprompt(Prompt)
end)
if not success then
Prompt:Destroy()
Disable3 = true
print("false fireproximityprompt")
end

print("true fireproximityprompt")
Prompt:Destroy()

if not replicatesignal then
Disable4 = true
print("false replicatesignal")
end
print("true replicatesignal")


if not hookmetamethod or not newcclosure then

Library:Notify("‰∏çÊîØÊåÅhookmetamethodÔºå‰∏Ä‰∫õÂäüËÉΩÂ∞ÜË¢´Á¶ÅÁî®",3)

print("false hookmetamethod")


Disable5 = true


end


print("true hookmetamethod")



ThemeManager = loadstring(game:HttpGet(repo..'addons/ThemeManager.lua'))()
SaveManager  = loadstring(game:HttpGet(repo..'addons/SaveManager.lua'))()
Options = Library.Options
Toggles = Library.Toggles
local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/mstudio45/MSESP/refs/heads/main/source.luau"))()

local Achievement = (function()
local Players = game:GetService("Players")
local TS = game:GetService("TweenService")
local Plr = Players.LocalPlayer
return function(data)
task.spawn(function()
local frame = Plr.PlayerGui.GlobalUI.AchievementsHolder.Achievement:Clone()
frame.Name = "LiveAchievement"
frame.Frame.Details.Title.Text = data.Title
frame.Frame.Details.Desc.Text = data.Desc
frame.Frame.Details.Reason.Text = data.Reason
frame.Frame.ImageLabel.Image = data.Image
frame.Size = UDim2.new(0, 0, 0, 0)
frame.Frame.Position = UDim2.new(1.1, 0, 0, 0)
frame.Visible = true
frame.Parent = Plr.PlayerGui.GlobalUI.AchievementsHolder
if data.Text then
frame.Frame.TextLabel.Text = data.Text
end
if data.TextColor then
frame.Frame.TextLabel.TextColor3 = data.TextColor
end
if data.UIStrokeColor then
frame.Frame.UIStroke.Color = data.UIStrokeColor
end
frame.Sound:Play()
frame:TweenSize(UDim2.new(1, 0, 0.2, 0), "In", "Quad", 0.8, true)
task.wait(0.8)
frame.Frame:TweenPosition(UDim2.new(0, 0, 0, 0), "Out", "Quad", 0.5, true)
TS:Create(frame.Frame.Glow, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In), { ImageTransparency = 1 }):Play()
task.wait(3)
frame.Frame:TweenPosition(UDim2.new(1.1, 0, 0, 0), "In", "Quad", 0.5, true)
task.wait(0.5)
frame:TweenSize(UDim2.new(1, 0, -0.1, 0), "InOut", "Quad", 0.5, true)
task.wait(0.5)
frame:Destroy()
end)
end
end)()

local ESPConfig = {
Tracer = {
Enabled = true,
Position = "Bottom",
Thickness = 1.0
},
TextSize = 16,
ShowDistance = true,
ShowTracers = false,
FillTransparency = 0.7,
OutlineTransparency = 0.4,
ESPType = "Highlight"
}

local ESPObjects = {}
local ESPEnabled = false

function ESPLibrary:AddESP(Part, Txt, Color)
if not Part or not Part.Parent then return end
    
local model = Part
if Part:IsA("BasePart") and Part.Parent and Part.Parent:IsA("Model") then
model = Part.Parent
end
    
if Part.Name == "Door" and Part.Parent and Part.Parent.Name == "Door" then
model = Part
end
    
if ESPObjects[model] then
ESPObjects[model]:Hide()
end
    
local espObject = ESPLibrary:Add({
Name = Txt,
Model = model,
Color = Color,
MaxDistance = 1000,
TextSize = ESPConfig.TextSize,
ESPType = ESPConfig.ESPType,
FillColor = Color,
OutlineColor = Color,
FillTransparency = ESPConfig.FillTransparency,
OutlineTransparency = ESPConfig.OutlineTransparency,
Tracer = { 
Enabled = ESPConfig.Tracer.Enabled,
Color = Color,
From = ESPConfig.Tracer.Position
}
})
    
ESPObjects[model] = espObject
espObject:Show()
end

function ESPLibrary:RemoveESP(Part)
local model = Part
if Part.Name == "Door" and Part.Parent and Part.Parent.Name == "Door" then
model = Part
elseif Part:IsA("BasePart") and Part.Parent and Part.Parent:IsA("Model") then
model = Part.Parent
end

if ESPObjects[model] then
ESPObjects[model]:Hide()
ESPObjects[model] = nil
end
end

function ESPLibrary:GenerateRandomString()
return game:GetService("HttpService"):GenerateGUID(false)
end

function ESPLibrary:Unload()
for model, espObject in pairs(ESPObjects) do
if espObject and typeof(espObject.Hide) == "function" then
espObject:Hide()
end
end
ESPObjects = {}
getgenv().ESPLibrary = nil
end

function UpdateAllESPConfig()
ESPLibrary.GlobalConfig.Distance = ESPConfig.ShowDistance
ESPLibrary.GlobalConfig.Tracers = ESPConfig.ShowTracers

for model, espObject in pairs(ESPObjects) do
if model and model.Parent and espObject and espObject.CurrentSettings then
espObject.CurrentSettings.TextSize = ESPConfig.TextSize
espObject.CurrentSettings.Tracer.Enabled = ESPConfig.Tracer.Enabled
espObject.CurrentSettings.Tracer.From = ESPConfig.Tracer.Position
espObject.CurrentSettings.Tracer.Thickness = ESPConfig.Tracer.Thickness
espObject.CurrentSettings.FillTransparency = ESPConfig.FillTransparency
espObject.CurrentSettings.OutlineTransparency = ESPConfig.OutlineTransparency
espObject.CurrentSettings.ESPType = ESPConfig.ESPType

espObject:Hide()
espObject:Show()
end
end
end

function RecreateAllESP()
local espStates = {
Door = Toggles.Door and Toggles.Door.Value,
HidingSpot = Toggles.HidingSpot and Toggles.HidingSpot.Value,
Players = Toggles.Players and Toggles.Players.Value,
Items = Toggles.Items and Toggles.Items.Value,
Gold = Toggles.Gold and Toggles.Gold.Value,
EntitesESP = Toggles.EntitesESP and Toggles.EntitesESP.Value,
Ladder = Toggles.Ladder and Toggles.Ladder.Value,
Chest = Toggles.Chest and Toggles.Chest.Value,
Stardust = Toggles.Stardust and Toggles.Stardust.Value,
TaskESP =  Toggles.TaskESP and Toggles.TaskESP.Value
}
    
for model, espObject in pairs(ESPObjects) do
if espObject and typeof(espObject.Hide) == "function" then
espObject:Hide()
end
end
ESPObjects = {}

for espType, isEnabled in pairs(espStates) do
if isEnabled then
if Toggles[espType] then
Toggles[espType]:SetValue(false)
Toggles[espType]:SetValue(true)
end
end
end
end

function UpdateFillTransparency(value)
ESPConfig.FillTransparency = value
for _, espObject in pairs(ESPObjects) do
if espObject and espObject.CurrentSettings then
espObject.CurrentSettings.FillTransparency = value
espObject:Hide()
espObject:Show()
end
end
end

function UpdateOutlineTransparency(value)
ESPConfig.OutlineTransparency = value
for _, espObject in pairs(ESPObjects) do
if espObject and espObject.CurrentSettings then
espObject.CurrentSettings.OutlineTransparency = value
espObject:Hide()
espObject:Show()
end
end
end

function UpdateTextSize(value)
ESPConfig.TextSize = value
for _, espObject in pairs(ESPObjects) do
if espObject and espObject.CurrentSettings then
espObject.CurrentSettings.TextSize = value
espObject:Hide()
espObject:Show()
end
end
end


local function shouldShowESP(roomNumber)
local currentRoom = LocalPlayer:GetAttribute("CurrentRoom")
if not currentRoom then return false end
return roomNumber == currentRoom or roomNumber == currentRoom + 1
end


local raycastParms = RaycastParams.new()

function GetNearestCloset()

local closest = nil
local MaxDistance = math.huge
local assets = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]
if assets then
for _, v in ipairs(assets:FindFirstChild("Assets",true):GetChildren()) do

if v.Name == "Wardrobe" or v.Name == "Rooms_Locker" or v.Name == "Rooms_Locker_Fridge" or v.Name == "Toolshed" or v.Name == "Locker_Large" or v.Name == "Backdoor_Wardrobe" or v.Name == "Bed" or v.Name == "Double_Bed" then
if v.PrimaryPart then

local Distance = (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude
if Distance < MaxDistance then
closest = v
MaxDistance = Distance 
end
end
end
end
end
return closest
end


function GetNearestLocker()



local closest = nil
local MaxDistance = math.huge

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do

if v.Name == "Rooms_Locker" or v.Name == "Rooms_Locker_Fridge" then
if v.PrimaryPart then

local Distance = (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude
if Distance < MaxDistance then
closest = v
MaxDistance = Distance 
end
end
end
end
return closest

end



function fireInteract(prompt)

if Disable3 == true then

prompt:InputHoldBegin()

prompt:InputHoldEnd(prompt.HoldDuration)

elseif Disable3 == false then

fireproximityprompt(prompt)

end



end



local Finish = nil

Finish = game:GetService("ProximityPromptService").PromptTriggered:Connect(function(v)
if Library.Unloaded == true then

Finish:Disconnect()
Finish = nil

end


if v.Name == "FakePrompt" then

if game.Players.LocalPlayer.Character:FindFirstChild("Lockpick") or game.Players.LocalPlayer.Character:FindFirstChild("SkeletonKey") then
local animator = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):WaitForChild("Animations",9e9).usefinish)
animator:Play()
elseif game.Players.LocalPlayer.Character:FindFirstChild("Shears") then
local animator = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):WaitForChild("Animations",9e9).promptanimend)
animator:Play()
game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):WaitForChild("Handle").sound_promptend:Play()
end


end

end)

local Hold = nil
Hold = game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(v)
if Library.Unloaded == true then

Hold:Disconnect()
Hold = nil

end
if v.Name == "FakePrompt" then

if game.Players.LocalPlayer.Character:FindFirstChild("Lockpick") or game.Players.LocalPlayer.Character:FindFirstChild("SkeletonKey") then
local animator = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):WaitForChild("Animations").use)
animator:Play()
elseif game.Players.LocalPlayer.Character:FindFirstChild("Shears") then
local animator = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):WaitForChild("Animations",9e9).promptanim)
animator:Play()
game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):WaitForChild("Handle").sound_prompt:Play()
end


end

end)

LocalPlayer:SetAttribute("StarringLoaded",true)


Floor = ReplicatedStorage.GameData.Floor


RemoteFolder = ReplicatedStorage:FindFirstChild("RemotesFolder")
MainGame = LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game
RequiredMainGame = require(LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game)
RemoteListener = MainGame.RemoteListener
Modules = RemoteListener.Modules

ClientModules = game:GetService("ReplicatedStorage"):FindFirstChild("ModulesClient") or game:GetService("ReplicatedStorage"):FindFirstChild("ClientModules") 
if ReplicatedStorage:FindFirstChild("RemotesFolder") then 
Modifiers = ReplicatedStorage:WaitForChild("LiveModifiers")
end
local PlayerGui  = LocalPlayer.PlayerGui 
Fog = Lighting:FindFirstChild("Fog") or Lighting:FindFirstChild("CaveAtmosphere")
CollisionClone = nil
CollisionClone2 = nil

Pathnode = Instance.new("Folder",workspace)
Pathnode.Name = "Path Node"

local JumpConnection 
local CleanUp
local Character = nil

if LocalPlayer.Character then

raycastParms.FilterDescendantsInstances = {LocalPlayer.Character}
raycastParms.FilterType = Enum.RaycastFilterType.Blacklist

if LocalPlayer.PlayerGui.MainUI.MainFrame.MobileButtons:FindFirstChild("JumpButton") then


JumpConnection = LocalPlayer.PlayerGui.MainUI.MainFrame.MobileButtons.JumpButton.MouseButton1Click:Connect(function()
if Toggles and Toggles.InfiniteJump and Toggles.InfiniteJump.Value then
if Character then

Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

end
end

end)

end


Character = LocalPlayer.Character
if Character.Collision:FindFirstChild("CollisionCrouch") then
Character.Collision.CollisionCrouch.Size = Vector3.new(0.5, 0.001, 3)
end
if ReplicatedStorage:FindFirstChild("RemotesFolder") then
CollisionClone = Character.CollisionPart:Clone()
CollisionClone.Parent = Character
CollisionClone.Massless = true
CollisionClone.CanCollide = false
CollisionClone.Name = "_CollisionPart"
if CollisionClone:FindFirstChild("CollisionCrouch") then
CollisionClone.CollisionCrouch:Destroy()
end

CollisionClone2 = Character.CollisionPart:Clone()
CollisionClone2.Parent = Character
CollisionClone2.Massless = true
CollisionClone2.CanCollide = false
CollisionClone2.Name = "_CollisionPart2"
if CollisionClone2:FindFirstChild("CollisionCrouch") then
CollisionClone2.CollisionCrouch:Destroy()
end
end
end


local NewCharacter = LocalPlayer.CharacterAdded:Connect(function()
task.wait(1.5)
if CrouchConnection then
CrouchConnection:Disconnect()
CrouchConnection = nil
end
if JumpConnection then
JumpConnection:Disconnect()
JumpConnection = nil
end


raycastParms.FilterDescendantsInstances = {LocalPlayer.Character}
raycastParms.FilterType = Enum.RaycastFilterType.Blacklist



if LocalPlayer.PlayerGui.MainUI.MainFrame.MobileButtons:FindFirstChild("JumpButton") then


JumpConnection = LocalPlayer.PlayerGui.MainUI.MainFrame.MobileButtons.JumpButton.MouseButton1Click:Connect(function()
if Toggles.InfiniteJump.Value then
if Character then

Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

end
end

end)

end



MainGame = LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game
RequiredMainGame = require(LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game)
RemoteListener = MainGame.RemoteListener
Modules = RemoteListener.Modules

Character = LocalPlayer.Character

if Character.Collision:FindFirstChild("CollisionCrouch") then
Character.Collision.CollisionCrouch.Size = Vector3.new(0.5, 0.001, 3)
end

if ReplicatedStorage:FindFirstChild("RemotesFolder") then
CollisionClone = Character.CollisionPart:Clone()
CollisionClone.Parent = Character
CollisionClone.Massless = true
CollisionClone.CanCollide = false
CollisionClone.Name = "_CollisionPart"
CollisionClone2 = Character.CollisionPart:Clone()
CollisionClone2.Parent = Character
CollisionClone2.Massless = true
CollisionClone2.CanCollide = false
CollisionClone2.Name = "_CollisionPart2"
if CollisionClone2:FindFirstChild("CollisionCrouch") then
CollisionClone2.CollisionCrouch:Destroy()
end
end

end)
local LatestRoom = ReplicatedStorage.GameData.LatestRoom.Value

local Connections = {}

if UIStyle == "LinoriaLib" then
Tabs = {
Player = Window:AddTab("Áé©ÂÆ∂"),
Exploits = Window:AddTab("ÊºèÊ¥û"),
Visuals = Window:AddTab("ËßÜËßâ"),
Floor = Window:AddTab("Ê•ºÂ±Ç"),
UISettings = Window:AddTab("ÈÖçÁΩÆ"),
Info = Window:AddTab("‰ø°ÊÅØ"),
Addons = Window:AddTab("Êèí‰ª∂"),
}
else
Tabs = {
Player = Window:AddTab({
Name = "Áé©ÂÆ∂",
Description = "Âü∫Á°ÄÂäüËÉΩ", 
Icon = "user"
}),
Exploits = Window:AddTab({
Name = "ÊºèÊ¥û",
Description = "Âà©Áî®DoorsÊ∏∏ÊàèÊºèÊ¥û", 
Icon = "bug"
}),
Visuals = Window:AddTab({
Name = "ËßÜËßâ",
Description = "Ê∏≤Êüì&ÈÄöÁü•", 
Icon = "scan-eye"
}),
Floor = Window:AddTab({
Name = "Ê•ºÂ±Ç",
Description = "Âü∫‰∫éÊ•ºÂ±Ç", 
Icon = "sparkles"
}),
UISettings = Window:AddTab({
Name = "ÈÖçÁΩÆ",
Description = "Áî®Êà∑ÁïåÈù¢&È¢ÑËÆæ", 
Icon = "settings"
}),
Info = Window:AddTab({
Name = "‰ø°ÊÅØ",
Description = "ÂÖ≥‰∫éStarRingÁöÑ‰ø°ÊÅØ", 
Icon = "info"
}),
Addons = Window:AddTab({
Name = "Êèí‰ª∂",
Description = "StarRingÁöÑÁ§æÂå∫Êèí‰ª∂", 
Icon = "boxes"
})
}
end


local Movement = Tabs.Player:AddLeftGroupbox("ÁßªÂä®")

local MiscBox = Tabs.Player:AddLeftGroupbox("ÊùÇÈ°π")

local Anti = Tabs.Exploits:AddLeftGroupbox('ÂÆû‰Ωì')

local Troll = Tabs.Exploits:AddLeftGroupbox('ÊÅ∂Êêû')

Automation = Tabs.Player:AddRightGroupbox('Ëá™Âä®Âåñ')
Bypass = Tabs.Exploits:AddRightGroupbox('ÁªïËøá')

local ReachBox = Tabs.Player:AddRightGroupbox('Ë∑ùÁ¶ª')

FloorAnti = Tabs.Floor:AddLeftGroupbox('Ê•ºÂ±ÇÁªïËøá')

ModifiersBox = Tabs.Floor:AddLeftGroupbox('‰øÆÈ•∞Á¨¶')

FloorAuto = Tabs.Floor:AddRightGroupbox('Ëá™Âä®Âåñ')

local TabBox4 = Tabs.Visuals:AddRightTabbox()

local NotifyBox = TabBox4:AddTab('ÈÄöÁü•')
local NySet = TabBox4:AddTab('ËÆæÁΩÆ')

local TabBox5 = Tabs.Visuals:AddRightTabbox()

local Camera = TabBox5:AddTab('Áõ∏Êú∫')
local Effect = TabBox5:AddTab('ÊïàÊûú')

local TabBox = Tabs.Visuals:AddLeftTabbox() 

ESP = TabBox:AddTab('ESP')
SettingsESP = TabBox:AddTab('ËÆæÁΩÆ')
ClosetTran = Tabs.Visuals:AddLeftGroupbox('ÈÄèÊòéÂ∫¶')

SettingsBox = Tabs.UISettings:AddLeftGroupbox('UI','wrench')

Tabs.Addons:UpdateWarningBox({
Title = "Ë≠¶Âëä",
Text = "ÈôåÁîüÊèí‰ª∂Êúâ‰∏ÄÂÆöÁöÑÂç±Èô©ÊÄßÔºåÊèí‰ª∂Ê∑ªÂä†Ë∑ØÂæÑ(Starring/Addons)",
IsNormal = false,
Visible = true,
LockSize = true,
})

local Contributors = Tabs.Info:AddLeftGroupbox("ÂºÄÂèë‰∫∫Âëò","user-round-check")
Contributors:AddLabel("[<font color=\"rgb(73,230,133)\">ÂçÉchange</font>] ÊâÄÊúâËÄÖ",true)

local TheScript = Tabs.Info:AddRightGroupbox("Ëá¥Ë∞¢","user-star")
TheScript:AddLabel("[<font color=\"rgb(73,230,133)\">mstudio45</font>] Êèê‰æõUIÂ∫ì",true)
TheScript:AddLabel("[<font color=\"rgb(73,230,133)\">mstudio45</font>] Êèê‰æõMSESPÂ∫ì",true)

if Floor.Value == "Rooms" then
function getLocker()
local Closest
for i,v in pairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Rooms_Locker" then
if v:FindFirstChild("Door") and v:FindFirstChild("HiddenPlayer") then
if v.HiddenPlayer.Value == nil then
if v.Door.Position.Y > -3 then
if Closest == nil then
Closest = v.Door
else
if (LocalPlayer.Character.HumanoidRootPart.Position - v.Door.Position).Magnitude < (Closest.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude then
Closest = v.Door
end
end
end
end
end
end
end
return Closest
end
function getPath()
local Part
local Entity = workspace:FindFirstChild("A60") or workspace:FindFirstChild("A120")
if Entity and Entity.Main.Position.Y > -4 then
Part = getLocker()
else
Part = workspace.CurrentRooms[ReplicatedStorage.GameData.LatestRoom.Value].Door.Door
end
return Part
end
local autoRoomsRunning = false
local autoRoomsThread = nil
local function startAutoRooms()
if autoRoomsRunning then return end
autoRoomsRunning = true
LocalPlayer.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
if not workspace:FindFirstChild("PathFindPartsFolder") then
local Folder = Instance.new("Folder")
Folder.Parent = workspace
Folder.Name = "PathFindPartsFolder"
end
if LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener.Modules:FindFirstChild("A90") then
LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener.Modules.A90.Name = "lol"
end
autoRoomsThread = task.spawn(function()
while Toggles.AutoRooms.Value and not Library.Unloaded and autoRoomsRunning do
local Destination = getPath()
if Destination and ReplicatedStorage.GameData.LatestRoom.Value ~= 1000 then
local path = PathfindingService:CreatePath({ WaypointSpacing = 1, AgentRadius = 1.5, AgentCanJump = false })
path:ComputeAsync(LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(0,2.5,0), Destination.Position)
local Waypoints = path:GetWaypoints()
if path.Status ~= Enum.PathStatus.NoPath then
if workspace:FindFirstChild("PathFindPartsFolder") then
workspace.PathFindPartsFolder:ClearAllChildren()
end
for _, Waypoint in pairs(Waypoints) do
local part = Instance.new("Part")
part.Size = Vector3.new(1,1,1)
part.Position = Waypoint.Position
part.Shape = "Cylinder"
part.Rotation = Vector3.new(0,0,90)
part.Material = "SmoothPlastic"
part.Anchored = true
part.CanCollide = false
if workspace:FindFirstChild("PathFindPartsFolder") then
part.Parent = workspace.PathFindPartsFolder
end
end
for _, Waypoint in pairs(Waypoints) do
if not Toggles.AutoRooms.Value or Library.Unloaded or not autoRoomsRunning then break end
if LocalPlayer.Character.HumanoidRootPart.Anchored == false then
LocalPlayer.Character.Humanoid:MoveTo(Waypoint.Position)
LocalPlayer.Character.Humanoid.MoveToFinished:Wait()
end
end
end
end
task.wait()
end
end)
end
local function stopAutoRooms()
autoRoomsRunning = false
if autoRoomsThread then
task.cancel(autoRoomsThread)
autoRoomsThread = nil
end
LocalPlayer.DevComputerMovementMode = Enum.DevComputerMovementMode.KeyboardMouse
if workspace:FindFirstChild("PathFindPartsFolder") then
workspace.PathFindPartsFolder:ClearAllChildren()
end
LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)
end
local function restartAutoRooms()
if Toggles.AutoRooms.Value then
Library:Notify("Ëá™Âä®ÊàøÈó¥[DEBUG] ËßÑÂàíË∑ØÁ∫ø‰∏≠...", 3)
stopAutoRooms()
task.wait(0.1)
startAutoRooms()
end
end
FloorAnti:AddToggle('AutoRooms',{
Text = "Ëá™Âä®ÊàøÈó¥",
Default = false
})
FloorAnti:AddLabel('‰∏çË¶ÅÂºÄÂêØÁ©øÂ¢ô',true)
local autoRoomsLastPosition = nil
local autoRoomsStuckStartTime = nil
local autoRoomsStuckThreshold = 2
Toggles.AutoRooms:OnChanged(function(Value)
if Value then
startAutoRooms()
else
stopAutoRooms()
end
end)
local stuckCheckConnection = RunService.Heartbeat:Connect(function()
if not Toggles.AutoRooms.Value or Library.Unloaded or not autoRoomsRunning then return end
local currentPosition = LocalPlayer.Character.HumanoidRootPart.Position
if autoRoomsLastPosition then
local distanceMoved = (currentPosition - autoRoomsLastPosition).Magnitude
if distanceMoved < 1 then
if not autoRoomsStuckStartTime then
autoRoomsStuckStartTime = tick()
else
local stuckDuration = tick() - autoRoomsStuckStartTime
if stuckDuration >= autoRoomsStuckThreshold then
restartAutoRooms()
autoRoomsStuckStartTime = nil
end
end
else
autoRoomsStuckStartTime = nil
end
end
autoRoomsLastPosition = currentPosition
end)
local renderConnection = RunService.RenderStepped:Connect(function()
if not Toggles.AutoRooms.Value or Library.Unloaded then return end
LocalPlayer.Character.HumanoidRootPart.CanCollide = false
LocalPlayer.Character.Collision.CanCollide = false
LocalPlayer.Character.Collision.CustomPhysicalProperties = PhysicalProperties.new(9e9,9e9,9e9)
if Toggles.SpeedBoost and Toggles.SpeedBoost.Value then
LocalPlayer.Character.Humanoid.WalkSpeed = Speed
else
LocalPlayer.Character.Humanoid.WalkSpeed = 16
end
local Path = getPath()
local Entity = workspace:FindFirstChild("A60") or workspace:FindFirstChild("A120")
if Entity then
if Path then
if Path.Parent.Name == "Rooms_Locker" then
if Entity.Main.Position.Y > -4 then
if (LocalPlayer.Character.HumanoidRootPart.Position - Path.Position).Magnitude < 5 then
if LocalPlayer.Character.HumanoidRootPart.Anchored == false then
fireproximityprompt(Path.Parent.HidePrompt)
end
end
end
end
end
if Entity.Main.Position.Y < -4 then
if LocalPlayer.Character.HumanoidRootPart.Anchored == true then
RemoteFolder.CamLock:FireServer()
end
end
else
if LocalPlayer.Character.HumanoidRootPart.Anchored == true then
RemoteFolder.CamLock:FireServer()
end
end
end)
local roomConnection = ReplicatedStorage.GameData.LatestRoom.Changed:Connect(function()
if not Toggles.AutoRooms.Value or Library.Unloaded then return end
if ReplicatedStorage.GameData.LatestRoom.Value == 1000 then
stopAutoRooms()
end
end)
table.insert(Connections, stuckCheckConnection)
table.insert(Connections, renderConnection)
table.insert(Connections, roomConnection)
FloorAnti:AddDivider()
end

if Floor.Value == "Hotel" and ReplicatedStorage:FindFirstChild("RemotesFolder") then

 Objects = {
DoorNormal = true,
DoorFrame = true,
Luggage_Cart_Crouch = true,
Carpet = true,
CarpetLight = true,
Luggage_Cart = true,
DropCeiling = true,
End_DoorFrame = true,

Start_DoorFrame = true,
TriggerEventCollision = true,
StairCollision = true

}
 
function canhit(part)

if part:IsA("BasePart") then
part.CanCollide = false
elseif part:IsA("Model") then

for _, v in pairs(part:GetChildren()) do
if v:IsA("BasePart") then
v.CanCollide = false


end
end


end


end

function moveTo(part)


local pos = part.Position + part.CFrame.LookVector * -2

local path = PathfindingService:CreatePath({
AgentRadius = 0.2,
AgentHeight = 0.1,
AgentCanJump = true,
AgentCanClimb = true,
WaypointSpacing = 3 
})

path:ComputeAsync(LocalPlayer.Character.HumanoidRootPart.Position, pos)

if path.Status == Enum.PathStatus.Success then

for _, waypoint in pairs(path:GetWaypoints()) do




LocalPlayer.Character.Humanoid:MoveTo(waypoint.Position)
LocalPlayer.Character.Humanoid.MoveToFinished:Wait()

end

end
end

end

FloorAuto:AddToggle('AutoEatCandies', {
    Text = "Ëá™Âä®ÂêÉÁ≥ñÊûú",
    Default = false,
})

ModifiersBox:AddButton({
Text = "Ê≠ª‰∫°ÂÜúÂú∫",
Func = function()
if not replicatesignal or not queue_on_teleport then
Library:Notify("‰Ω†ÁöÑÊâßË°åÂô®‰∏çÊîØÊåÅÂ§çÂà∂‰ø°Âè∑",3)
return 
end

if queue_on_teleport then

Library:Notify("Áé∞Âú®ÂºÄÂßãÁ≠âÂæÖ",2)
loadstring(game:HttpGet("https://raw.githubusercontent.com/TheHunterSolo1/Op-Ninja-Simulator-/Main/M1reset"))()

queue_on_teleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/TheHunterSolo1/Op-Ninja-Simulator-/Main/M1reset"))()')

end

end
})

ModifiersBox:AddDivider()

SettingsBox:AddToggle('FpsUnlocker',{
     Text = "Ëß£ÈîÅÂ∏ßÁéá",
     Default = true,
Callback = function(Value)
setfpscap(Value and 9999999 or 60)

end
})

SettingsBox:AddToggle('WatermarkToggle',{
     Text = "ÊòæÁ§∫Ê∞¥Âç∞",
     Default = false,
     Callback = function(Value)
        Library:SetWatermarkVisibility(Value)
     end
})

local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;
 
local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;
 
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;
 
    Library:SetWatermark(('Starring User | %s FPS | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);

SettingsBox:AddToggle('PlaySound',{
     Text = "Êí≠ÊîæÂ£∞Èü≥",
     Default = true,
Callback = function(Value)
PlayingSound = Value

end
})




SettingsBox:AddDropdown("NotificationSide", {
	Values = { "Left", "Right" },
	Default = "Right",

	Text = "ÈÄöÁü•‰ΩçÁΩÆ",

	Callback = function(Value)
		Library:SetNotifySide(Value)
	end,
})

local OptionNotify = "Obsidian"
function Notify(txt,desc,reason)
if OptionNotify then 
Library:Notify(txt,3)

 elseif OptionNotify == "Doors" then
local Achievement = game:GetService("Players").LocalPlayer.PlayerGui.MainUI.AchievementsHolder.Achievement:Clone()
Achievement.Size = UDim2.new(0, 0, 0, 0)
Achievement.Visible = true
Achievement:WaitForChild("Sound",9e9):Play()
Achievement:WaitForChild("Frame"):WaitForChild("Details").Title.Text = txt
Achievement:WaitForChild("Frame"):WaitForChild("Details").Reason.Text = reason
Achievement:WaitForChild("Frame"):WaitForChild("Details").Desc.Text = desc


game:GetService("TweenService"):Create(Achievement,TweenInfo.new(1.5),{Size = UDim2.new(1, 0, 0, 0)}):Play()

task.wait(1)
Achievement:Destroy()

end

end

ReachBox:AddToggle('PromptReach',{
     Text = "Â¢ûÈïø‰∫íÂä®",
     Default = false,
Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v:IsA("ProximityPrompt") then
v:SetAttribute("Distance",v.MaxActivationDistance)
v.MaxActivationDistance = v.MaxActivationDistance * promptReachMultiplier
end
end
else
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v:IsA("ProximityPrompt") then
v.MaxActivationDistance = v:GetAttribute("Distance") or 7
end
end
end
end
})

local Range = 20
ReachBox:AddToggle('DoorReach',{
     Text = "Âª∂ÈïøÂºÄÈó®",
     Default = false
})

ReachBox:AddSlider("PromptReachMultiplier", {
    Text = "‰∫íÂä®Ë∑ùÁ¶ª",
    Default = 1.0,
    Min = 1.0,
    Max = 2.0,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        promptReachMultiplier = Value
        if Toggles.PromptReach and Toggles.PromptReach.Value then
            Toggles.PromptReach:SetValue(false)
            Toggles.PromptReach:SetValue(true)
        end
    end,
})
ReachBox:AddSlider("DoorReachRange", {
        Text = "ÂºÄÈó®Ë∑ùÁ¶ª",
        Default = 20,
        Min = 15,
        Max = 30,
        Rounding = 1,
        Compact = true,

        Callback = function(Value)
          Range = Value

     end,      
})


Effect:AddToggle('NoCutscenes',{
     Text = "Êó†ËøáÂú∫Âä®Áîª",
     Default = false
})

Effect:AddToggle('AntiSpider',{
     Text = "Êó†ËúòËõõË∑≥ËÑ∏",
     Default = false,
Callback = function(Value)
local SpiderModule = ClientModules.EntityModules:FindFirstChild("SpiderJumpscare") or ClientModules.EntityModules:FindFirstChild("_SpiderJumpscare")
if SpiderModule then
SpiderModule.Name = Value and "_SpiderJumpscare" or "SpiderJumpscare"
end
end
})

Effect:AddToggle('AntiGlitch',{
     Text = "Êó†ÊïÖÈöúË∑≥ËÑ∏",
     Default = false,
     Callback = function(Value)
local GlitchModule = ClientModules.EntityModules:FindFirstChild("Glitch") or ClientModules.EntityModules:FindFirstChild("_Glitch")
if GlitchModule then
GlitchModule.Name = Value and "_Glitch" or "Glitch"
end
end
})

local notifysound = 4590657391
local VoidModule

MainGame = LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game
RequiredMainGame = require(LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game)
RemoteListener = MainGame.RemoteListener
Modules = RemoteListener.Modules

local success, result = pcall(function()
VoidModule = require(ClientModules.EntityModules.Void)
end)
if not success then
pcall(function()
VoidModule = require(game.ReplicatedStorage.ModulesClient.EntityModules.Void)
end)
end

Effect:AddToggle('AntiVoid',{
     Text = "Êó†ËôöÁ©∫Ë∑≥ËÑ∏",
     Default = false,
Callback = function(Value)
if VoidModule then
if Value then
if not VoidModule.originalStuff then
VoidModule.originalStuff = VoidModule.stuff
end
VoidModule.stuff = function() end
else
if VoidModule.originalStuff then
VoidModule.stuff = VoidModule.originalStuff
end
end
end
end
})

Effect:AddToggle('NoBatDecor',{
     Text = "Êó†ËùôËù†Ë£ÖÈ•∞",
     Default = false,
Callback = function(Value)
if Value then
for _, decor in ipairs(workspace:GetDescendants()) do
if decor.Name == "HangingHalloweenDecor" and decor:IsA("Model") then
decor:Destroy()
end
end
             
if not batDecorConnection then
batDecorConnection = workspace.DescendantAdded:Connect(function(descendant)
if Toggles.NoBatDecor and Toggles.NoBatDecor.Value then
if descendant.Name == "HangingHalloweenDecor" and descendant:IsA("Model") then
descendant:Destroy()
end
end
end)
end
else
if batDecorConnection then
batDecorConnection:Disconnect()
batDecorConnection = nil
end
end
end
})

local batDecorConnection = nil

local TransparencyValue = 0.5
ClosetTran:AddSlider("TransparencySlider", {
        Text = "ÊüúÂ≠êÈÄèÊòéÂ∫¶",
        Default = 0.5,
        Min = 0.1,
        Max = 1,
        Rounding = 1,
        Compact = true,

        Callback = function(Value)
        TransparencyValue   = Value

     end,      
})

ClosetTran:AddToggle('TransparencyCloset',{
Text = "ÊüúÂ≠êÈÄèÊòé",
Default = false
})
ClosetTran:AddDivider()
local CartTransparencyValue = 0.5
ClosetTran:AddSlider("CartTransparencySlider", {
        Text = "ÁüøËΩ¶ÈÄèÊòéÂ∫¶",
        Default = 0.5,
        Min = 0.1,
        Max = 1,
        Rounding = 1,
        Compact = true,

        Callback = function(Value)
        CartTransparencyValue   = Value

     end,      
})

ClosetTran:AddToggle('TransparencyCart',{
Text = "ÁüøËΩ¶ÈÄèÊòé",
Default = false
})

Effect:AddToggle('NoVignette', {
    Text = "ÊüúÂ≠êÊó†ÊöóËßí",
    Default = false
})

local noVignetteLoop = nil

Toggles.NoVignette:OnChanged(function(Value)
if Value then

noVignetteLoop = RunService.Heartbeat:Connect(function()
if not Toggles.NoVignette.Value then return end

local playerGui = LocalPlayer.PlayerGui
if playerGui and playerGui:FindFirstChild("MainUI") then
local mainUI = playerGui.MainUI
if mainUI and mainUI:FindFirstChild("MainFrame") then
local mainFrame = mainUI.MainFrame
if mainFrame and mainFrame:FindFirstChild("HideVignette") then
mainFrame.HideVignette.Visible = false
end
end
end
end)
else
if noVignetteLoop then
noVignetteLoop:Disconnect()
noVignetteLoop = nil
end
end
end)

Effect:AddToggle('NoOxygenVignette', {
    Text = "Êó†Áº∫Ê∞ßÊïàÊûú",
    Default = false
})

local noOxygenVignetteLoop = nil
Toggles.NoOxygenVignette:OnChanged(function(Value)
if Value then
noOxygenVignetteLoop = RunService.Heartbeat:Connect(function()
if not Toggles.NoOxygenVignette.Value then return end
local playerGui = LocalPlayer.PlayerGui
if playerGui and playerGui:FindFirstChild("MainUI") then
local mainUI = playerGui.MainUI
if mainUI and mainUI:FindFirstChild("MainFrame") then
local mainFrame = mainUI.MainFrame
if mainFrame and mainFrame:FindFirstChild("EyelidsVignette") then
mainFrame.EyelidsVignette.Visible = false
end
end
end
local oxygenBlur = Lighting:FindFirstChild("OxygenBlur")
if oxygenBlur then
oxygenBlur:Destroy()
end
local oxygenCC = Lighting:FindFirstChild("OxygenCC")
if oxygenCC then
oxygenCC:Destroy()
end
end)
else
if noOxygenVignetteLoop then
noOxygenVignetteLoop:Disconnect()
noOxygenVignetteLoop = nil
end
end
end)

Camera:AddToggle('Fullbright',{
     Text = "ÂÖ®‰∫Æ",
     Default = false,
Callback = function(Value)
if Value then

else
game.Lighting.Ambient = Color3.fromRGB(0, 0, 0)


end
end
})

local skyRemovalConnection = nil

Camera:AddToggle('AntiFog',{
Text = "Ê≤°ÊúâÈõæ",
Default = false,
Callback = function(Value)
if Value then
if Lighting:FindFirstChildOfClass("Sky") then
Lighting:FindFirstChildOfClass("Sky"):Destroy()
end

skyRemovalConnection = RunService.Heartbeat:Connect(function()
if not Toggles.AntiFog.Value then
return
end

local currentSky = Lighting:FindFirstChildOfClass("Sky")
if currentSky then
currentSky:Destroy()
end
end)
else
if skyRemovalConnection then
skyRemovalConnection:Disconnect()
skyRemovalConnection = nil
end
end
end
})

Camera:AddToggle('NoCameraShake',{
     Text = "Êó†Áõ∏Êú∫ÊäñÂä®",
     Default = false,
Disabled = Disable1
})

Camera:AddToggle('NoLookBob',{
     Text = "Êó†ËßÜËßíÊäñÂä®",
     Default = false
})
Toggles.NoLookBob:OnChanged(function()
if RequiredMainGame and RequiredMainGame.spring then
RequiredMainGame.spring.Speed = (Toggles.NoLookBob.Value and 9e9 or 8)
end
end)
task.spawn(function()
task.wait(0.5)
if RequiredMainGame and RequiredMainGame.spring then
RequiredMainGame.spring.Speed = (Toggles.NoLookBob and Toggles.NoLookBob.Value and 9e9 or 8)
end
end)
Camera:AddDivider()

local ThirdPersonHandler = {enabled = false, offset = Vector3.new(2, 0, 6)}

local function ThirdPersonStep()
if not ThirdPersonHandler.enabled then return end

local cam = workspace.CurrentCamera
local char = LocalPlayer.Character
if not cam or not char then return end

cam.CFrame = cam.CFrame * CFrame.new(ThirdPersonHandler.offset)

for _, part in ipairs(char:GetDescendants()) do
if part:IsA("BasePart") and part.Name == "Head" then
part.LocalTransparencyModifier = 0
elseif part:IsA("Accessory") and part:FindFirstChild("Handle") then
part.Handle.LocalTransparencyModifier = 0
end
end
end

pcall(function() RunService:UnbindFromRenderStep("THIRD_PERSON_SYS") end)
RunService:BindToRenderStep("THIRD_PERSON_SYS", Enum.RenderPriority.Camera.Value+1, ThirdPersonStep)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
if ThirdPersonHandler.enabled then
ThirdPersonHandler.enabled = false
task.wait(0.1)
ThirdPersonHandler.enabled = true
end
end)

local X, Y, Z = 2, 0, 6

Camera:AddToggle('ThirdPerson', {
    Text = "Á¨¨‰∏â‰∫∫Áß∞",
    Default = false,
Callback = function(Value)
ThirdPersonHandler.enabled = Value
if not Value then
local char = LocalPlayer.Character
if char then
for _, part in ipairs(char:GetDescendants()) do
if part:IsA("BasePart") and part.Name == "Head" then
part.LocalTransparencyModifier = 1
elseif part:IsA("Accessory") and part:FindFirstChild("Handle") then
part.Handle.LocalTransparencyModifier = 1
end
end
end
end
end
}):AddKeyPicker('ThirdPKeybind', {
    Default = 'T',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Á¨¨‰∏â‰∫∫Áß∞',
    NoUI = false,
Callback = function(Value) end,
ChangedCallback = function(New) end
})

Camera:AddSlider("X", {
    Text = "X",
    Default = X,
    Min = -10,
    Max = 10,
    Rounding = 0,
    Compact = true,
Callback = function(Value)
X = Value
ThirdPersonHandler.offset = Vector3.new(X, Y, Z)
end      
})

Camera:AddSlider("Y", {
    Text = "Y",
    Default = Y,
    Min = -10,
    Max = 10,
    Rounding = 0,
    Compact = true,
Callback = function(Value)
Y = Value
ThirdPersonHandler.offset = Vector3.new(X, Y, Z)
end      
})

Camera:AddSlider("Z", {
    Text = "Z",
    Default = Z,
    Min = -10,
    Max = 10,
    Rounding = 0,
    Compact = true,
Callback = function(Value)
Z = Value
ThirdPersonHandler.offset = Vector3.new(X, Y, Z)
end      
})
Camera:AddDivider()


local SpectateTable = {
RushMoving = true,
AmbushMoving = true,
A60 = true,
A120 = true,
GlitchRush = true,
GlitchAmbush = true
}


Camera:AddToggle('SpectateEntity',{
     Text = "ËßÇÂØüÂÆû‰Ωì",
     Default = false
})

NotifyBox:AddDropdown("EntitiesPicker", {
        Values = { "Rush","Ambush","A-60","A-120","Eyes","Lookman","Blitz","GlitchRush","GlitchAmbush","Monument","Groundskeeper","Seek"},
        Default = 1,
        Multi = true,

        Text = "ÂÆû‰Ωì",
        

        Callback = function(Value)
               
        end,

        
})

NotifyBox:AddToggle('EntityNotifys',{
     Text = "ÈÄöÁü•ÂÆû‰Ωì",
     Default = false
})

NySet:AddToggle('NotifyChat',{
     Text = "ËÅäÂ§©ÈÄöÁü•ÂÆû‰Ωì",
     Default = false,
Callback = function(Value)
if Value then
if not notifyChatRunning then
notifyChatRunning = true

local TextChatService = game:GetService("TextChatService")
local Workspace = game:GetService("Workspace")

local entityNameMap = {
Rush = "Rush",
Ambush = "Ambush", 
["A-60"] = "A-60",
["A-120"] = "A-120",
Eyes = "Eyes",
Lookman = "Lookman",
Blitz = "Blitz",
Monument = "Monument",
Groundskeeper = "Groundskeeper",
Seek = "SeekÂèëÂ∞ÑÂô®"
}

local entityModelMap = {
Rush = "RushMoving",
Ambush = "AmbushMoving",
["A-60"] = "A60",
["A-120"] = "A120",
Eyes = "Eyes",
Lookman = "BackdoorLookman",
Blitz = "BackdoorRush",
Monument = "MonumentEntity",
Groundskeeper = "Groundskeeper",
Seek = "SeekMovingNewClone"
}

local detectedInstances = {}

for entityName, modelName in pairs(entityModelMap) do
detectedInstances[modelName] = {}
end

local function sendMessage(message)
if TextChatService and TextChatService.TextChannels then
local channel = TextChatService.TextChannels:FindFirstChild("RBXGeneral")
if channel then
channel:SendAsync(message)
end
end
end

local function checkForEntities()
if not notifyChatRunning then return end

local children = Workspace:GetDescendants()

for _, child in ipairs(children) do
if child:IsA("Model") then
for entityName, modelName in pairs(entityModelMap) do
if Options.EntitiesPicker.Value[entityName] then
if child.Name == modelName then
if not detectedInstances[modelName][child] then
detectedInstances[modelName][child] = true
local displayName = entityNameMap[entityName] or entityName

local messageFormat = Options.ChatMessageFormat.Value or "% Â∑≤ÁîüÊàê"
local chatMessage = messageFormat:gsub("%%", displayName)

sendMessage(chatMessage)
end
break
end
end
end
end
end

for modelName, instances in pairs(detectedInstances) do
for instance in pairs(instances) do
if not instance:IsDescendantOf(Workspace) then
detectedInstances[modelName][instance] = nil
end
end
end
end

notifyChatConnection = game:GetService("RunService").Heartbeat:Connect(function()
if not notifyChatRunning then
return
end
checkForEntities()
end)
end
else
notifyChatRunning = false
if notifyChatConnection then
notifyChatConnection:Disconnect()
notifyChatConnection = nil
end
end
end
})

NySet:AddInput("ChatMessageFormat", {
    Default = "% Â∑≤ÁîüÊàê",
    Numeric = false,
    Finished = false,
    Text = "ËÅäÂ§©Ê∂àÊÅØÊ†ºÂºè",
    Tooltip = "% Â∞ÜË¢´ÊõøÊç¢‰∏∫ÂÆû‰ΩìÂêçÁß∞",
    Callback = function(Value)
    end,
})

local notifyChatRunning = false
local notifyChatConnection = nil

if notifyChatConnection then
notifyChatConnection:Disconnect()
notifyChatConnection = nil
end
notifyChatRunning = false
NySet:AddDivider()

NySet:AddDropdown("NotificationStyle", {
    Values = {"Obsidian", "Doors"},
    Default = "Obsidian",
    Text = "ÈÄöÁü•Ê†∑Âºè",
Callback = function(Value)
OptionNotify = Value
end,
})

MiscBox:AddButton({
     Text = "ÈáçÁΩÆ‰∫∫Áâ©",
DoubleClick = true,
     Func = function()
if Disable4 == false then

replicatesignal(LocalPlayer.Kill)

elseif Disable4 == true then

LocalPlayer.Character.Humanoid.Health = 0

end

end
})

MiscBox:AddButton({
     Text = "ÂÜçÁé©‰∏ÄÊ¨°",
DoubleClick = true,
     Func = function()
RemoteFolder.PlayAgain:FireServer()
end
})

MiscBox:AddButton({
     Text = "ËøîÂõûÂ§ßÂéÖ",
DoubleClick = true,
     Func = function()
RemoteFolder.Lobby:FireServer()
end
})


MiscBox:AddButton({
     Text = "Áé©ÂÆ∂Â§çÊ¥ª",
DoubleClick = true,
     Func = function()
RemoteFolder.Revive:FireServer()
end
})

 Speed = 15
Movement:AddSlider("SpeedBoostSlider", {
        Text = "ÁßªÂä®ÈÄüÂ∫¶ÊªëÂùó",
        Default = 15,
        Min = 15,
        Max = 21,
        Rounding = 1,

        Callback = function(Value)
           Speed = Value

     end,      
})

local LadderSpeedSlider = Movement:AddSlider("LadderSpeedBoost", {
    Text = "Áà¨Ê¢ØÂ≠êÂä†ÈÄü",
    Default = 0,
    Min = 0,
    Max = 50,
    Rounding = 0,
    Compact = true,
Callback = function(Value)
end,
})

local function updateLadderSpeedSlider()
local isMinesFloor = Floor.Value == "Mines"
LadderSpeedSlider:SetDisabled(not isMinesFloor)
if not isMinesFloor then
Options.LadderSpeedBoost:SetValue(0)
end
end
updateLadderSpeedSlider()
if Floor:IsA("StringValue") then
table.insert(Connections, Floor.Changed:Connect(updateLadderSpeedSlider))
end

local MaxSlopeAngle = 45
Movement:AddSlider("MaxSlopeAngleSlider", {
    Text = "ÊúÄÂ§ßÊñúÂù°ËßíÂ∫¶",
    Default = 45,
    Min = 0,
    Max = 90,
    Rounding = 0,
    Compact = true,
    Callback = function(Value)
        MaxSlopeAngle = Value
        if Character and Character:FindFirstChild("Humanoid") then
            Character.Humanoid.MaxSlopeAngle = Value
        end
    end,
})

Movement:AddToggle('SpeedBoost',{
     Text = "ÁßªÂä®ÈÄüÂ∫¶",
     Default = false
})

Movement:AddDivider()

Movement:AddSlider("JumpPowerSlider", {
        Text = "Ë∑≥Ë∑ÉÊèêÂçá",
        Default = 5,
        Min = 0,
        Max = 50,
        Rounding = 1,
Compact = false,
Callback = function(Value)
end,      
})

local jumpPowerValue = 5
local jumpPowerConnections = {}
local function applyJumpPower()
local character = LocalPlayer.Character
if not character then return end
local humanoid = character:FindFirstChildOfClass("Humanoid")
if not humanoid then return end
if jumpPowerConnections.character then
jumpPowerConnections.character:Disconnect()
jumpPowerConnections.character = nil
end
if jumpPowerConnections.jumpPower then
jumpPowerConnections.jumpPower:Disconnect()
jumpPowerConnections.jumpPower = nil
end
if jumpPowerConnections.jumpHeight then
jumpPowerConnections.jumpHeight:Disconnect()
jumpPowerConnections.jumpHeight = nil
end
if humanoid.UseJumpPower then
humanoid.JumpPower = jumpPowerValue
jumpPowerConnections.jumpPower = humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
if humanoid.JumpPower ~= jumpPowerValue then
humanoid.JumpPower = jumpPowerValue
end
end)
else
humanoid.JumpHeight = jumpPowerValue
jumpPowerConnections.jumpHeight = humanoid:GetPropertyChangedSignal("JumpHeight"):Connect(function()
if humanoid.JumpHeight ~= jumpPowerValue then
humanoid.JumpHeight = jumpPowerValue
end
end)
end
end

if LocalPlayer.Character then
applyJumpPower()
end
jumpPowerConnections.character = LocalPlayer.CharacterAdded:Connect(function(character)
character:WaitForChildOfClass("Humanoid")
applyJumpPower()
end)
Options.JumpPowerSlider:OnChanged(function()
jumpPowerValue = Options.JumpPowerSlider.Value
applyJumpPower()
end)

Movement:AddToggle('EnableJump',{
     Text = "ÂêØÁî®Ë∑≥Ë∑É",
     Default = false
})

Movement:AddToggle('InfiniteJump',{
     Text = "Êó†ÈôêË∑≥Ë∑É",
     Default = false
})
Movement:AddDivider()

SettingsESP:AddDropdown("ESPType", {
Values = {"Text", "SphereAdornment", "CylinderAdornment", "Adornment", "SelectionBox", "Highlight"},
Default = "Highlight",
Text = "ESPÁ±ªÂûã",
Callback = function(Value)
ESPConfig.ESPType = Value
RecreateAllESP()
end,
})

SettingsESP:AddToggle('EnableShowDistancws',{
     Text = "ÊòæÁ§∫Ë∑ùÁ¶ª",
     Default = false,
Callback = function(Value)
    ESPConfig.ShowDistance = Value
    UpdateAllESPConfig()
end
})

SettingsESP:AddToggle("ShowTracersToggle", {
    Text = "ËøΩË∏™Á∫ø",
    Default = ESPConfig.ShowTracers,
    Callback = function(Value)
        ESPConfig.ShowTracers = Value
        UpdateAllESPConfig()
    end,
})

SettingsESP:AddToggle('RainbowESP', {
    Text = 'ÂΩ©Ëâ≤ESP',
    Default = false,
    Callback = function(Value)
        ESPLibrary.GlobalConfig.Rainbow = Value
        UpdateAllESPConfig()
    end
})

SettingsESP:AddDropdown("TracerPosition", {
    Values = {"Top", "Bottom", "Center", "Mouse"},
    Default = ESPConfig.Tracer.Position,
    Text = "ËøΩË∏™Á∫ø‰ΩçÁΩÆ",
    Callback = function(Value)
        ESPConfig.Tracer.Position = Value
        RecreateAllESP()
    end,
})

SettingsESP:AddSlider("TextSizeSlider", {
    Text = "ÊñáÊú¨Â§ßÂ∞è",
    Default = ESPConfig.TextSize,
    Min = 10,
    Max = 50,
    Rounding = 0,
    Compact = true,
    Callback = function(Value)
        ESPConfig.TextSize = Value
        UpdateAllESPConfig()
    end,
})

SettingsESP:AddSlider("TracerThicknessSlider", {
    Text = "ËøΩË∏™Á∫øÁ≤óÁªÜ",
    Default = ESPConfig.Tracer.Thickness,
    Min = 0.1,
    Max = 5.0,
    Rounding = 1,
    Compact = true,
Callback = function(Value)
ESPConfig.Tracer.Thickness = Value
end
})

SettingsESP:AddSlider("ESPFillTransparency", {
    Text = "Â°´ÂÖÖÈÄèÊòéÂ∫¶",
    Default = 0.7,
    Min = 0,
    Max = 1.0,
    Rounding = 2,
    Compact = true,
Callback = function(Value)
for _, espObject in pairs(ESPObjects) do
if espObject and espObject.CurrentSettings then
espObject.CurrentSettings.FillTransparency = Value
end
end
end
})

SettingsESP:AddSlider("ESPOutlineTransparency", {
    Text = "ËΩÆÂªìÈÄèÊòéÂ∫¶",
    Default = 0.4,
    Min = 0,
    Max = 1.0,
    Rounding = 2,
    Compact = true,
Callback = function(Value)
for _, espObject in pairs(ESPObjects) do
if espObject and espObject.CurrentSettings then
espObject.CurrentSettings.OutlineTransparency = Value
end
end
end
})

Ignore = {
HidePrompt = true,

RiftPrompt = true,

StarRiftPrompt = true,

InteractPrompt = true,

FakePrompt = true,

PushPrompt = true,

ClimbPrompt = true,

RevivePrompt = true,

PropPrompt = true,

NoHidingLilBro = true,

DonatePrompt = true

}




 AutoInteractTable = {}
Automation:AddToggle('AutoInteract',{
     Text = "Ëá™Âä®‰∫íÂä®",
     Default = false,

Callback = function(Value)
if Value then

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do

if not Ignore[v.Name] then


if v:IsA("ProximityPrompt") then

table.insert(AutoInteractTable,v)
end
end
end
else
table.clear(AutoInteractTable)
end
end
}):AddKeyPicker('AutoInteractKeybind', {


Default = 'R',
SyncToggleState = true,
Mode = 'Toggle',
Text = 'Ëá™Âä®‰∫íÂä®',
NoUI = false,
Callback = function(Value)
end,
ChangedCallback = function(New)
end
})

Automation:AddDropdown("IgnoreList", {
Values = {"JeffÁâ©ÂìÅ","ÈáëÂ∏Å","Á≥ñÊûú","‰∏¢ÂºÉÁâ©ÂìÅ","ÊïÖÈöúÊñπÂùó","Ê≠ª‰∫°Á≥ñÊûú","GrampyÁâ©ÂìÅ"},
    Default = 1,
    Multi = true,
    Text = "ÂøΩÁï•ÂàóË°®",
Callback = function(Value)
end,
})

Automation:AddDivider()

Automation:AddToggle('AutoHeartbeatMiniGame',{

     Text = "Ëá™Âä®ÂøÉË∑≥Â∞èÊ∏∏Êàè",
     Disabled = Disable5,
     Default = false

})

local UnlockDistance = 40

Automation:AddSlider('UnlockPadLockDistance', {
	Text = 'Ëß£ÊåÇÈîÅË∑ùÁ¶ª',
	Min = 40, Max = 100, Default = 40,
	Rounding = 1,
	Callback = function(v)
		UnlockDistance = v
	end
})
local RepStore = game:GetService("ReplicatedStorage")
local PS = game:GetService("Players")
local PlayerGui = LocalPlayer.PlayerGui

local function findPL()
	
return RemoteFolder:FindFirstChild("PL")
end

local PL = findPL()

local function parsePaper(paper, hintsContainer)
	local children = paper:WaitForChild("UI"):GetChildren()
	local map, order = {}, {}
	for i = 1, #children do
		local c = children[i]
		local idx = tonumber(c.Name)
		if idx then
			local key = c.ImageRectOffset.X .. "_" .. c.ImageRectOffset.Y
			map[key] = { idx, "" }
			order[idx] = key
		end
	end
	if hintsContainer then
		for _, ic in ipairs(hintsContainer:GetChildren()) do
			if ic.Name == "Icon" then
				local key = ic.ImageRectOffset.X .. "_" .. ic.ImageRectOffset.Y
				local entry = map[key]
				if entry then
					local lbl = ic:FindFirstChildWhichIsA("TextLabel")
					if lbl then entry[2] = lbl.Text end
				end
			end
		end
	end
	local parts = {}
	for i = 1, #order do
		parts[i] = map[ order[i] ][2]
	end
	return table.concat(parts)
end

local function manageToggle(toggleName, mode,place)
	local seenPapers = {}
	local lastCodes = {}
	local lastFireTimes = {}
	local padPart
	local conns = {}
	local enabled = false

	local function disconnectAll()
		for _, c in ipairs(conns) do
			if c.Disconnect then c:Disconnect() end
		end
		conns = {}
	end

	local function updatePad()
		local idx = RepStore.GameData.LatestRoom.Value
		local roomRoot = workspace.CurrentRooms and workspace.CurrentRooms[idx]
		if roomRoot then
			local pad = roomRoot:FindFirstChild("Padlock", true)
			padPart = pad and (pad.PrimaryPart or pad:FindFirstChildWhichIsA("BasePart"))
		else
			padPart = nil
		end
	end

	local function handleCode(paper)
		local hints = PlayerGui:FindFirstChild("PermUI") and PlayerGui.PermUI:FindFirstChild("Hints")
		local code = parsePaper(paper, hints)
		if lastCodes[paper] ~= code and code ~= "" then
			lastCodes[paper] = code
			if mode == "Fire" then
				if padPart and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
					local dist = (LocalPlayer.Character.HumanoidRootPart.Position - padPart.Position).Magnitude
					if dist <= UnlockDistance then
						local now = tick()
						if not lastFireTimes[code] or now - lastFireTimes[code] > 1 then
							local ok = pcall(function() if PL then PL:FireServer(code) end end)
							if ok then lastFireTimes[code] = now end
						end
					end
				end
			else
				Library:Notify("ÊåÇÈîÅÂØÜÁ†ÅÊòØ "..code,3)
			end
		end
	end

	local function addPaper(paper)
		if seenPapers[paper] then return end
		seenPapers[paper] = true
		conns[#conns+1] = paper.DescendantAdded:Connect(function()
			handleCode(paper)
		end)
		conns[#conns+1] = paper.DescendantRemoving:Connect(function()
			handleCode(paper)
		end)
		handleCode(paper)
	end

	local function removePaper(paper)
		seenPapers[paper] = nil
		lastCodes[paper] = nil
	end

	place:AddToggle(toggleName, {
		Text = (mode == "Fire") and "Ëá™Âä®Ëß£ÊåÇÈîÅ" or "ÈÄöÁü•ÊåÇÈîÅÂØÜÁ†Å",
		Default = false,
		Tooltip = (mode == "Fire") and "Âú®ÊúâÊïàËåÉÂõ¥ÂÜÖËá™Âä®Ëß£ÈîÅÊåÇÈîÅ" or "Â∞ÜÂØÜÁ†ÅÊòæÁ§∫‰∏∫ÈÄöÁü•",
		Callback = function(on)
			enabled = on
			disconnectAll()
			table.clear(seenPapers)
			table.clear(lastCodes)
			table.clear(lastFireTimes)

			if enabled then
				while RepStore.GameData.LatestRoom.Value < 50 do
					task.wait(0.4)
					if not enabled then return end
				end

				updatePad()
				conns[#conns+1] = RepStore.GameData.LatestRoom:GetPropertyChangedSignal("Value"):Connect(updatePad)

				local function scanContainer(container)
					for _, obj in ipairs(container:GetChildren()) do
						if obj.Name == "LibraryHintPaper" or obj.Name == "LibraryHintPaperHard" then
							addPaper(obj)
						end
					end
				end

				scanContainer(LocalPlayer.Character)
				scanContainer(LocalPlayer.Backpack)

				conns[#conns+1] = LocalPlayer.Backpack.ChildAdded:Connect(function(obj)
					if obj.Name == "LibraryHintPaper" or obj.Name == "LibraryHintPaperHard" then
						addPaper(obj)
					end
				end)
				conns[#conns+1] = LocalPlayer.Backpack.ChildRemoved:Connect(removePaper)
				conns[#conns+1] = LocalPlayer.Backpack.ChildAdded:Connect(function(obj)
					if obj.Name == "LibraryHintPaper" or obj.Name == "LibraryHintPaperHard" then
						addPaper(obj)
					end
				end)
				conns[#conns+1] = LocalPlayer.Backpack.ChildRemoved:Connect(removePaper)
			end
		end
	})
end

manageToggle("AutoCodeFire",   "Fire",Automation)
manageToggle("AutoCodeNotify", "Notify",NotifyBox)

local oxygenNotifyRunning = false
local oxygenNotifyUI = nil
local oxygenNotifyConnection = nil
local oxygenHideTimer = nil

NotifyBox:AddToggle('OxygenNotify',{
     Text = "ÈÄöÁü•Ê∞ßÊ∞î",
     Default = false,
Callback = function(Value)
if Value then
if not oxygenNotifyRunning then
oxygenNotifyRunning = true

if not oxygenNotifyUI then
oxygenNotifyUI = Instance.new("ScreenGui")
oxygenNotifyUI.Name = "OxygenNotifyUI"
oxygenNotifyUI.Parent = game:GetService("CoreGui")
oxygenNotifyUI.ResetOnSpawn = false
oxygenNotifyUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 120, 0, 45)
frame.Position = UDim2.new(0.5, -100, 0.8, -30)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.BackgroundTransparency = 0.3
frame.Parent = oxygenNotifyUI

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = frame

local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "Ê∞ßÊ∞î: 100%"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.TextSize = 18
textLabel.Font = Enum.Font.Gotham
textLabel.Parent = frame

oxygenNotifyUI.Enabled = false
end

local function updateOxygenDisplay(oxygenValue)
if oxygenNotifyUI and oxygenNotifyUI:FindFirstChildOfClass("Frame") then
local frame = oxygenNotifyUI:FindFirstChildOfClass("Frame")
local textLabel = frame:FindFirstChildOfClass("TextLabel")

if textLabel then
textLabel.Text = "Ê∞ßÊ∞î: " .. tostring(math.floor(oxygenValue)) .. "%"

if oxygenValue < 30 then
textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
elseif oxygenValue < 60 then
textLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
else
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
end
end
end
end

local function checkOxygen(character)
if not character then
character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

if not character then return nil end

local oxygenValue = character:GetAttribute("Oxygen")
if oxygenValue then
return oxygenValue
end

local oxygenObj = character:FindFirstChild("Oxygen")
if oxygenObj and oxygenObj:IsA("NumberValue") then
return oxygenObj.Value
end

return nil
end

oxygenNotifyConnection = game:GetService("RunService").Heartbeat:Connect(function()
if not oxygenNotifyRunning then
return
end

local character = LocalPlayer.Character

if not character then
oxygenNotifyUI.Enabled = false
return
end

local oxygenValue = checkOxygen(character)

if oxygenValue then
if oxygenValue < 100 then
oxygenNotifyUI.Enabled = true
updateOxygenDisplay(oxygenValue)

if oxygenHideTimer then
oxygenHideTimer:Cancel()
oxygenHideTimer = nil
end
else
if oxygenNotifyUI.Enabled and not oxygenHideTimer then
oxygenHideTimer = task.delay(3, function()
if oxygenNotifyUI and oxygenNotifyRunning then
oxygenNotifyUI.Enabled = false
oxygenHideTimer = nil
end
end)
end
end
else
oxygenNotifyUI.Enabled = false
end
end)

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
if not oxygenNotifyRunning then return end

task.wait(1)
local oxygenValue = checkOxygen(newCharacter)
if oxygenValue and oxygenValue < 100 then
oxygenNotifyUI.Enabled = true
updateOxygenDisplay(oxygenValue)
else
oxygenNotifyUI.Enabled = false
end
end)
end
else
oxygenNotifyRunning = false

if oxygenNotifyConnection then
oxygenNotifyConnection:Disconnect()
oxygenNotifyConnection = nil
end

if oxygenHideTimer then
oxygenHideTimer:Cancel()
oxygenHideTimer = nil
end

if oxygenNotifyUI then
oxygenNotifyUI.Enabled = false
end
end
end
})

local hasteClockUI = nil
local hasteClockConnection = nil
local hasteClockRoomConnection = nil

NotifyBox:AddToggle('HasteClock',{
     Text = "ÈÄöÁü•ÂÄíËÆ°Êó∂",
     Default = false,
Callback = function(Value)
if Value then
if not hasteClockUI then
hasteClockUI = Instance.new("ScreenGui")
hasteClockUI.Name = "HasteClockUI"
hasteClockUI.Parent = game:GetService("CoreGui")
hasteClockUI.ResetOnSpawn = false
hasteClockUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 150, 0, 45)
frame.Position = UDim2.new(0.5, 100, 0.8, -30)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.BackgroundTransparency = 0.3
frame.Parent = hasteClockUI
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = frame
local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "ÂÄíËÆ°Êó∂: --"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.TextSize = 18
textLabel.Font = Enum.Font.Gotham
textLabel.Parent = frame
hasteClockUI.Enabled = false
end
local function getCurrentRoomTimer()
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
if not localPlayer then return nil end
local currentRoom = localPlayer:GetAttribute("CurrentRoom")
if not currentRoom then return nil end
local roomKey = tostring(currentRoom)
local currentRooms = workspace:FindFirstChild("CurrentRooms")
if not currentRooms then return nil end
local room = currentRooms:FindFirstChild(roomKey)
if not room then return nil end
local door = room:FindFirstChild("Door")
if not door then return nil end
local displayTimer = door:FindFirstChild("DisplayTimer")
if displayTimer and displayTimer:FindFirstChild("Text") then
local textObj = displayTimer.Text
if textObj and textObj.Text and textObj.Text ~= "" then
return textObj.Text
end
end
local doorModel = door:FindFirstChild("Door")
if doorModel then
local backdoorDisplayPlate = doorModel:FindFirstChild("BackdoorDisplayPlate")
if backdoorDisplayPlate then
displayTimer = backdoorDisplayPlate:FindFirstChild("DisplayTimer")
if displayTimer and displayTimer:FindFirstChild("Text") then
local textObj = displayTimer.Text
if textObj and textObj.Text and textObj.Text ~= "" then
return textObj.Text
end
end
end
end
return nil
end
local function updateTimerDisplay(timerText)
if hasteClockUI and hasteClockUI:FindFirstChildOfClass("Frame") then
local frame = hasteClockUI:FindFirstChildOfClass("Frame")
local textLabel = frame:FindFirstChildOfClass("TextLabel")
if textLabel then
textLabel.Text = "ÂÄíËÆ°Êó∂: " .. timerText
end
end
end
hasteClockConnection = game:GetService("RunService").Heartbeat:Connect(function()
if not Toggles.HasteClock.Value then
return
end
local timerText = getCurrentRoomTimer()
if timerText and timerText ~= "" and timerText ~= "..." then
hasteClockUI.Enabled = true
updateTimerDisplay(timerText)
else
hasteClockUI.Enabled = false
end
end)
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
hasteClockRoomConnection = localPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
if not Toggles.HasteClock.Value then return end
hasteClockUI.Enabled = true
updateTimerDisplay("...")
task.delay(2, function()
if Toggles.HasteClock.Value then
local timerText = getCurrentRoomTimer()
if not timerText or timerText == "" or timerText == "..." then
hasteClockUI.Enabled = false
end
end
end)
end)
else
if hasteClockConnection then
hasteClockConnection:Disconnect()
hasteClockConnection = nil
end
if hasteClockRoomConnection then
hasteClockRoomConnection:Disconnect()
hasteClockRoomConnection = nil
end
if hasteClockUI then
hasteClockUI.Enabled = false
end
end
end
})

local hidingTimeConnection = nil
local hideMonsterHook = nil
local hidingAttributeConnection = nil
local hidingNotification = nil
local hidingStartTime = nil
local currentHideDuration = nil

NotifyBox:AddToggle('HidingTimeNotify',{
     Text = "ÈÄöÁü•Ë∫≤ËóèÊó∂Èó¥",
     Default = false,
Callback = function(Value)
if Value then
if not hidingTimeConnection then
if not hideMonsterHook then
local hideMonsterEvent = RemoteFolder:FindFirstChild("HideMonster")
if hideMonsterEvent then
hideMonsterHook = hideMonsterEvent.OnClientEvent:Connect(function(hideDuration)
if Toggles.HidingTimeNotify.Value then
hidingStartTime = tick()
currentHideDuration = hideDuration
if hidingNotification then
hidingNotification:Destroy()
end
hidingNotification = Library:Notify({
Title = "Áé©ÂÆ∂Ë∫≤Ëóè‰∏≠...",
Description = "Ë∫≤ËóèÂâ©‰ΩôÊó∂Èó¥: " .. hideDuration .. "Áßí",
Persist = true,
})
end
end)
end
end
hidingTimeConnection = RunService.Heartbeat:Connect(function()
if not Toggles.HidingTimeNotify.Value then return end
local isHiding = LocalPlayer.Character and LocalPlayer.Character:GetAttribute("Hiding") == true
if isHiding and hidingStartTime and currentHideDuration then
local currentTime = tick()
local elapsedTime = currentTime - hidingStartTime
local remainingTime = math.max(0, currentHideDuration - elapsedTime)
local formattedTime = string.format("%.1f", remainingTime)
if hidingNotification then
hidingNotification:ChangeTitle("Áé©ÂÆ∂Ë∫≤Ëóè‰∏≠...")
hidingNotification:ChangeDescription("Ë∫≤ËóèÂâ©‰ΩôÊó∂Èó¥: " .. formattedTime .. "Áßí")
end
if remainingTime <= 0 then
if hidingNotification then
hidingNotification:Destroy()
hidingNotification = nil
end
hidingStartTime = nil
currentHideDuration = nil
end
elseif not isHiding then
if hidingNotification then
hidingNotification:Destroy()
hidingNotification = nil
end
hidingStartTime = nil
currentHideDuration = nil
end
end)
if not hidingAttributeConnection then
hidingAttributeConnection = LocalPlayer.Character:GetAttributeChangedSignal("Hiding"):Connect(function()
if not Toggles.HidingTimeNotify.Value then return end
local isHiding = LocalPlayer.Character:GetAttribute("Hiding")
if not isHiding and hidingNotification then
hidingNotification:Destroy()
hidingNotification = nil
hidingStartTime = nil
currentHideDuration = nil
end
end)
end
end
else
if hidingTimeConnection then
hidingTimeConnection:Disconnect()
hidingTimeConnection = nil
end
if hideMonsterHook then
hideMonsterHook:Disconnect()
hideMonsterHook = nil
end
if hidingAttributeConnection then
hidingAttributeConnection:Disconnect()
hidingAttributeConnection = nil
end
if hidingNotification then
hidingNotification:Destroy()
hidingNotification = nil
end
hidingStartTime = nil
currentHideDuration = nil
end
end
})

Automation:AddDivider()
Automation:AddDropdown("BreakerBoxMode", {
    Values = {"ÂêàÊ≥ï", "ÊºèÊ¥û"},
    Default = "ÂêàÊ≥ï",
    Text = "Êñ≠Ë∑ØÂô®ÁÆ±Ëß£Ê≥ï",
Callback = function(Value)
end
})

local Breaker = nil
Automation:AddToggle('AutoBreakerBox',{
Text = "Ëá™Âä®Êñ≠Ë∑ØÂô®ÁÆ±",
Default = false,
Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "ElevatorBreaker" then
Breaker = v
     end
end
 
while task.wait() do
if not Toggles.AutoBreakerBox.Value then break end
if Breaker then
if Options.BreakerBoxMode and Options.BreakerBoxMode.Value == "ÊºèÊ¥û" then
local Event = game:GetService("ReplicatedStorage").RemotesFolder.EBF
if Event then
Event:FireServer()
end
else
for _, v in ipairs(Breaker:GetChildren()) do
if v.Name == "BreakerSwitch" then
if v:GetAttribute("ID") == tonumber(Breaker:WaitForChild("SurfaceGui").Frame.Code.Text) then
if  Breaker:WaitForChild("SurfaceGui").Frame.Code.Frame.BackgroundTransparency == 0  then
v:SetAttribute("Enabled",true)
if v:WaitForChild("Sound").Playing == false then
v:WaitForChild("Sound",1e1).Playing = true
end
v.Material = Enum.Material.Neon
v:WaitForChild("Light",1e1).Attachment.Spark:Emit(1)
v:WaitForChild("PrismaticConstraint").TargetPosition = -0.2
else
v:SetAttribute("Enabled",false)
if v:WaitForChild("Sound").Playing == false then
v:WaitForChild("Sound",1e1).Playing = true
end
v:WaitForChild("PrismaticConstraint").TargetPosition = 0.2
v.Material = Enum.Material.Glass
end
end
end
end
end
end
end
end
end
})

local EntitysTable = {
RushMoving = 85,
BackdoorRush = 85,
AmbushMoving = 144,
GlitchRush = 120,
GlitchAmbush = 155,
A60 = 130,
A120 = 75
}

Automation:AddToggle('AutoCloset',{
     Text = "Ëá™Âä®Ë∫≤Ëóè",
     Default = false,
     Risky = true
}):AddKeyPicker('AutoClosetKeybind', {


		Default = 'Q',
		SyncToggleState = true,
		Mode = 'Toggle',
		Text = 'Ëá™Âä®Ë∫≤Ëóè',
		NoUI = false,
		Callback = function(Value)
		end,
		ChangedCallback = function(New)
		end
	})

local autoGlitchEnabled = false
local autoGlitchConnection = nil

Automation:AddToggle('AutoGlitch', {
    Text = "Ëá™Âä®ÊïÖÈöú",
    Default = false,
    Callback = function(Value)
        autoGlitchEnabled = Value
        
        if autoGlitchEnabled then
            autoGlitchConnection = RunService.Heartbeat:Connect(function()
                if autoGlitchEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local character = LocalPlayer.Character
                    local humanoidRootPart = character.HumanoidRootPart
                    
                    local lookVector = humanoidRootPart.CFrame.LookVector
                    
                    local teleportPosition = humanoidRootPart.Position + (lookVector * 10000)
                    
                    character:PivotTo(CFrame.new(teleportPosition))
                end
            end)
        else
            if autoGlitchConnection then
                autoGlitchConnection:Disconnect()
                autoGlitchConnection = nil
            end
        end
    end
})

Movement:AddToggle('Noacceleration',{
     Text = "Êó†ÊâìÊªë",
     Default = false
})

Movement:AddToggle('InstantPrompt',{
     Text = "Âø´ÈÄü‰∫íÂä®",
     Default = false,
    Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do



if v:IsA("ProximityPrompt") then


v:SetAttribute("Hold",v.HoldDuration)

v.HoldDuration = 0

end

end

else


for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do



if v:IsA("ProximityPrompt") then



v.HoldDuration = v:GetAttribute("Hold") or 0.7

end


end

end

end
})

Movement:AddToggle('PromptClip',{
     Text = "Á©øÂ¢ô‰∫íÂä®",
     Default = false,
Callback = function(Value)
if Value then

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do


if v:IsA("ProximityPrompt") then


v.RequiresLineOfSight = false


end


end

else

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do


if v:IsA("ProximityPrompt") then


v.RequiresLineOfSight = true


end


end



end

end

})

Movement:AddDivider()
Movement:AddToggle('NoClosetExitDelay',{
     Text = "Êó†Âá∫ÊüúÂª∂Ëøü",
     Default = false
})
Movement:AddToggle('AntiAfk',{
     Text = "Èò≤ÊåÇÊú∫",
     Default = false
})
table.insert(Connections,LocalPlayer.Idled:Connect(function()

if Toggles.AntiAfk.Value then

VirtualUser:CaptureController()

VirtualUser:ClickButton2(Vector2.new())



end
end))
Movement:AddToggle('AntiLag',{
     Text = "Èò≤Âç°È°ø",
     Default = false,
    Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v:IsA("BasePart") then
v.Material = Enum.Material.Plastic
end
if v.Name == "LightFixture" or v.Name == "Carpet" or v.Name == "CarpetLight" then
v:Destroy()
end



end

end
end

})
Movement:AddDivider()
Fly = Fly or {}
Fly.Enabled = false
Fly.Speed = 15
Fly.FlyBody = nil
Fly.FlyGyro = nil

local renderConn 
local charAddedConn = nil
function Fly.SetupBodies(char)
local root = char:FindFirstChild("HumanoidRootPart")
if not root then return end
local bv = Instance.new("BodyVelocity")
bv.Name = "FlyBodyVelocity"
bv.MaxForce = Vector3.new(9e99, 9e99, 9e99)
bv.Velocity = Vector3.zero
bv.Parent = root
Fly.FlyBody = bv
local bg = Instance.new("BodyGyro")
bg.Name = "FlyBodyGyro"
bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
local cam = workspace.CurrentCamera
if cam then
bg.CFrame = cam.CFrame
end
bg.Parent = root
Fly.FlyGyro = bg

local humanoid = char:FindFirstChild("Humanoid")
if humanoid then
humanoid.PlatformStand = true
end
end

function Fly.CleanupBodies()
if Fly.FlyBody then
Fly.FlyBody:Destroy()
Fly.FlyBody = nil
end
if Fly.FlyGyro then
Fly.FlyGyro:Destroy()
Fly.FlyGyro = nil
end

if Character then
local humanoid = Character:FindFirstChild("Humanoid")
if humanoid then
humanoid.PlatformStand = false
end
end
end

local function onRenderStepped()
if not Fly.Enabled then return end

local char = Character
if not char then return end

local humanoid = char:FindFirstChild("Humanoid")
local root = char:FindFirstChild("HumanoidRootPart")
local cam = workspace.CurrentCamera
if not humanoid or not root or not Fly.FlyBody or not Fly.FlyGyro or not cam then
return
end

local dir = Vector3.zero

if UserInputService.KeyboardEnabled then
local forward = UserInputService:IsKeyDown(Enum.KeyCode.W)
local back    = UserInputService:IsKeyDown(Enum.KeyCode.S)
local left    = UserInputService:IsKeyDown(Enum.KeyCode.A)
local right   = UserInputService:IsKeyDown(Enum.KeyCode.D)

local camCFrame = cam.CFrame
local lookVec = camCFrame.LookVector
local rightVec = camCFrame.RightVector

if forward then
dir = dir + lookVec
end
if back then
dir = dir - lookVec
end
if left then
dir = dir - rightVec
end
if right then
dir = dir + rightVec
end
else
local moveDir = humanoid.MoveDirection
if moveDir.Magnitude > 0 then
local camCFrame = cam.CFrame
local flatLook = Vector3.new(camCFrame.LookVector.X, 0, camCFrame.LookVector.Z)
local flatRight = Vector3.new(camCFrame.RightVector.X, 0, camCFrame.RightVector.Z)
if flatLook.Magnitude > 0 then
flatLook = flatLook.Unit
end
if flatRight.Magnitude > 0 then
flatRight = flatRight.Unit
end

local forwardWeight = moveDir:Dot(flatLook)
local rightWeight = moveDir:Dot(flatRight)
dir = camCFrame.LookVector * forwardWeight + camCFrame.RightVector * rightWeight
end
end

if dir.Magnitude > 0 then
Fly.FlyBody.Velocity = dir.Unit * Fly.Speed
else
Fly.FlyBody.Velocity = Vector3.zero
end

Fly.FlyGyro.CFrame = cam.CFrame

humanoid.PlatformStand = true
end

function Fly.Enable()
if Fly.Enabled then return end
Fly.Enabled = true

local char = Character 
if char then
Fly.SetupBodies(char)
end

if not renderConn then
renderConn = RunService.RenderStepped:Connect(onRenderStepped)
end

if not charAddedConn then
charAddedConn = player.CharacterAdded:Connect(function(char2)
if Fly.Enabled then
char2:WaitForChild("HumanoidRootPart")
Fly.SetupBodies(char2)
end
end)
end
end

function Fly.Disable()
if not Fly.Enabled then return end
Fly.Enabled = false

Fly.CleanupBodies()

if renderConn then
renderConn:Disconnect()
renderConn = nil
end

if charAddedConn then
charAddedConn:Disconnect()
charAddedConn = nil
end
end

function Fly.Toggle()
if Fly.Enabled then
Fly.Disable()
else
Fly.Enable()
end
end

function Fly.SetSpeed(newSpeed)
Fly.Speed = newSpeed or Fly.Speed
end

FlySpeed = Movement:AddSlider("FlySpeed", {
	Text = "È£ûË°åÈÄüÂ∫¶",
	Min = 10,
	Max = 21,
	Default = Fly.Speed,
	Rounding = 0,
Callback = function(v)
Fly.SetSpeed(v)
end
})

Movement:AddToggle("Fly", {
	Text = "È£ûË°å",
	Default = false,
Callback = function(enabled)
if enabled then
Fly.Enable()
else
Fly.Disable()
end
end
}):AddKeyPicker('Fly Keybind', {

Default = 'F', 
SyncToggleState = true,
Mode = 'Toggle',
Text = 'È£ûË°å',
NoUI = false,
Callback = function(Value)
end,
ChangedCallback = function(New)
end
})

Movement:AddToggle('Noclip',{
     Text = "Á©øÂ¢ô",
     Default = false
}):AddKeyPicker('NoclipKeybind', {

Default = 'N',
Mode = 'Toggle',
Text = 'Á©øÂ¢ô',
NoUI = false,
Callback = function(Value)
end,
SyncToggleState = true,
ChangedCallback = function(New)
end
})

Toggles.Noclip:OnChanged(function(Value)
if not Value then 
LocalPlayer.Character.Collision.CanCollide = true 
if Character.Collision:FindFirstChild("CollisionCrouch") then
LocalPlayer.Character.Collision.CollisionCrouch.CanCollide = true
end
LocalPlayer.Character.HumanoidRootPart.CanCollide = true
if LocalPlayer.Character:FindFirstChild("CollisionPart") then
LocalPlayer.Character:FindFirstChild("CollisionPart").CanCollide = true
end
end
end)

local FOVhandler = {mem={o=nil,r=nil,u=nil,base={}}, loop=false, cam=nil}

local function FOVstep()
local parent = LocalPlayer.PlayerGui
if not parent then return end
    
FOVhandler.mem.o = (FOVhandler.mem.o and FOVhandler.mem.o.Parent) and FOVhandler.mem.o or Instance.new("NumberValue", parent)
    
local o = FOVhandler.mem.o.Value or 0
local sum = 0
for i=1,#FOVhandler.mem.base do
local v = FOVhandler.mem.base[i]
if not v or not v.Parent then 
v = Instance.new("NumberValue", parent)
FOVhandler.mem.base[i] = v 
end
sum = sum + (v.Value or 0)
end
local target = (o ~= 0 and o) or sum
local cam = workspace.CurrentCamera
if not cam then return end

if cam ~= FOVhandler.cam then
FOVhandler.cam = cam
end

if FOVhandler.loop and target > 0 then
local vis = math.clamp(target, 25, 120)
if cam.FieldOfView ~= vis then 
cam.FieldOfView = vis 
end
end
end

pcall(function() RunService:UnbindFromRenderStep("FOV_SYS") end)
RunService:BindToRenderStep("FOV_SYS", Enum.RenderPriority.Camera.Value+1, FOVstep)

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
FOVhandler.cam = workspace.CurrentCamera
end)

local View = 70
Camera:AddSlider("FieldofViewAdjust", {
    Text = "ËßÜÈáéÊªëÂùó",
    Default = 70,
    Min = 70,
    Max = 120,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
View = Value
if not FOVhandler.mem.base[1] then
FOVhandler.mem.base[1] = Instance.new("NumberValue", LocalPlayer.PlayerGui)
end
FOVhandler.mem.base[1].Value = Value
if Toggles.Fieldofview.Value then
local cam = workspace.CurrentCamera
if cam then
local vis = math.clamp(Value, 25, 120)
cam.FieldOfView = vis
end
end
end
})

Camera:AddToggle('Fieldofview', {
    Text = "ËßÜÈáé",
    Default = false,
    Callback = function(Value)
if Value then
FOVhandler.loop = true
if not FOVhandler.mem.base[1] then
FOVhandler.mem.base[1] = Instance.new("NumberValue", LocalPlayer.PlayerGui)
end
FOVhandler.mem.base[1].Value = View
local cam = workspace.CurrentCamera
if cam then
local vis = math.clamp(View, 25, 120)
cam.FieldOfView = vis
end
else
FOVhandler.loop = false
if FOVhandler.mem.base[1] then
FOVhandler.mem.base[1].Value = 0
end
end
end
})
Anti:AddToggle('AntiDread',{
     Text = "Èò≤ Dread",
     Default = false,
Callback = function(Value)
local Dread = Modules:FindFirstChild("Dread") or Modules:FindFirstChild("_Dread")
if Dread then
Dread.Name = Value and "_Dread" or "Dread"

end
end
})

Anti:AddToggle('AntiScreech',{
     Text = "Èò≤ Screech",
     Default = false,
Callback = function(Value)
local Screech = Modules:FindFirstChild("Screech") or Modules:FindFirstChild("_Screech")
Screech.Name = Value and "_Screech" or "Screech"


end
})


Anti:AddToggle('AntiA90',{
     Text = "Èò≤ A90",
     Default = false,
Callback = function(Value)
local A90 = Modules:FindFirstChild("A90") or Modules:FindFirstChild("_A90")
if A90 then
A90.Name = Value and "_A90" or "A90"

end
end
})

Anti:AddToggle('AntiEyes',{
     Text = "Èò≤ Eyes",
     Default = false
})


Anti:AddToggle('AntiSnare',{
     Text = "Èò≤ Snare",
     Default = false,
      Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Snare" and v.Parent and v.Parent.Name ~= "Snare" then
v:WaitForChild("Hitbox").CanTouch = false
end
end
else
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Snare" and v.Parent and v.Parent.Name ~= "Snare" then
v:WaitForChild("Hitbox").CanTouch = true
end
end

end
end
})

Anti:AddToggle('AntiDupe',{
     Text = "Èò≤ Dupe",
     Default = false,
Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "DoorFake" then
v:WaitForChild("Hidden").CanTouch = false
if v:FindFirstChild("Lock") then
v:FindFirstChild("Lock"):FindFirstChildOfClass("ProximityPrompt").ClickablePrompt = false
end
end
end
else
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "DoorFake" then
v:WaitForChild("Hidden").CanTouch = false
if v:FindFirstChild("Lock") then
v:FindFirstChild("Lock"):FindFirstChildOfClass("ProximityPrompt").ClickablePrompt = false
end
end
end
end

end
})

Anti:AddToggle('AntiHalt',{
     Text = "Èò≤ Halt",
     Default = false,
Callback = function(Value)
local Halt = ClientModules.EntityModules:FindFirstChild("Shade") or
ClientModules.EntityModules:FindFirstChild("_Shade") 
Halt.Name = Value and "_Shade" or "Shade"
end
})

Anti:AddToggle('AntiHear',{
     Text = "Èò≤È£ûÂì•Âê¨Âäõ",
     Default = false
})
Toggles.AntiHear:OnChanged(function(Value)
if not Value then
RemoteFolder.Crouch:FireServer(false)
end
end)

local nothitted = false


local direction = Vector3.new(0, -50, 0)
task.spawn(function()

while task.wait(0.35) do
if LocalPlayer.Character and not Library.Unloaded then 
local origin = LocalPlayer.Character.HumanoidRootPart.Position
local result = workspace:Raycast(origin, direction, raycastParms)
if result then
nothitted = false

else

nothitted = true

end

end

end


end)

Troll:AddToggle("Spamtoolz", { 
    Text = "Êª•Áî®‰ªñ‰∫∫Â∑•ÂÖ∑", 
    Default = false, 
}):AddKeyPicker("Spamtoolz_X", { 
    Default = "X", 
    SyncToggleState = false, 
    Mode = "Toggle", 
    Text = "Êª•Áî®‰ªñ‰∫∫Â∑•ÂÖ∑", 
    NoUI = false, 
})

Troll:AddToggle("StunPlayer", {
    Text = "Áú©Êôï",
    Default = false,
Callback = function(Value)
if LocalPlayer.Character then
LocalPlayer.Character:SetAttribute("Stunned", Value)
end
end
})

LocalPlayer.CharacterAdded:Connect(function(character)
task.wait(0.5)
if Toggles.StunPlayer and Toggles.StunPlayer.Value then
character:SetAttribute("Stunned", true)
end
end)

local SpeedBypassInterval = 0.216

if ReplicatedStorage:FindFirstChild("RemotesFolder") then
Bypass:AddToggle('SpeedBypass',{
     Text = "ÈÄüÂ∫¶ÁªïËøá",
     Default = false,
Callback = function(Value)
Options.SpeedBoostSlider:SetMax(Value and 100 or 21)
Options.SpeedBoostSlider:SetValue(Value and Options.SpeedBoostSlider.Value or 21)
Options.FlySpeed:SetMax(Value and 100 or 21)
Options.FlySpeed:SetValue(Value and Options.FlySpeed.Value or 21)

while true do
    task.wait(SpeedBypassInterval)
    if alive then
        local CollisionClon = LocalPlayer.Character:WaitForChild("_CollisionPart")
        local CollisionClon2 = LocalPlayer.Character:WaitForChild("_CollisionPart2")
        
        if not Toggles.SpeedBypass.Value or Library.Unloaded then
            CollisionClon.Massless = true
            CollisionClon2.Massless = true
            break 
        end
        
        if Character.CollisionPart.Anchored or nothitted or Toggles.AnticheatManipulation and Toggles.AnticheatManipulation.Value then
            CollisionClon.Massless = true
            CollisionClon2.Massless = true
            task.wait(0.35)
        else
            CollisionClon.Massless = true
            CollisionClon2.Massless = true
            task.wait(SpeedBypassInterval)
            CollisionClon2.Massless = false
            CollisionClon.Massless = false
        end
    end
end
end,
})
end
if not ReplicatedStorage:FindFirstChild("RemotesFolder") then


Options.SpeedBoostSlider:SetMax(115)
Options.FlySpeed:SetMax(115)
end

Bypass:AddSlider("SpeedBypassInterval", {
    Text = "ÈÄüÂ∫¶ÁªïËøáÈó¥Èöî",
    Default = 0.216,
    Min = 0.200,
    Max = 0.230,
    Rounding = 3,
    Compact = true,
    Callback = function(Value)
        SpeedBypassInterval = Value
    end,
})

Bypass:AddDivider()
local DropTable = {
RushMoving = 54,
AmbushMoving = 67,
A60 = 70
}


Bypass:AddToggle('InfiniteCrucifix', {
	Text = "Êó†ÈôêÂçÅÂ≠óÊû∂",
	Default = false,
    Risky = true,
    Tooltip = "‰Ω†ÂèØËÉΩ‰ºöÊ≠ªÊàñÂ§±ÂéªÂçÅÂ≠óÊû∂"
})

local InfiniteCrucifixConnection

InfiniteCrucifixConnection = RunService.RenderStepped:Connect(function()

if Toggles.InfiniteCrucifix.Value then

for _, v in ipairs(workspace:GetChildren()) do

local Entity = DropTable[v.Name]

if Entity and v.PrimaryPart then
v.PrimaryPart.CanCollide = true
v.PrimaryPart.CanQuery = true
local origin2  = LocalPlayer.Character.CollisionPart.Position
local direction2 = (v.PrimaryPart.Position - origin2)
local result2 = workspace:Raycast(origin2, direction2, raycastParms)

if result2 and result2.Instance:IsDescendantOf(v) then

if (LocalPlayer.Character.CollisionPart.Position - v.PrimaryPart.Position).Magnitude < Entity then

ReplicatedStorage.RemotesFolder.DropItem:FireServer(LocalPlayer.Character:FindFirstChildOfClass("Tool"))

task.wait(0.54)
if Workspace:FindFirstChild("Drops") and Workspace.Drops:FindFirstChild("Crucifix") then
fireproximityprompt(workspace.Drops:WaitForChild("Crucifix"):FindFirstChildOfClass("ProximityPrompt"))
end
end
end
end
end
end
end)

 if ReplicatedStorage:FindFirstChild("RemotesFolder") then
local dropRemote = RemoteFolder:FindFirstChild("DropItem")


function addFake(prompt, mode)
	if not prompt or not prompt:IsA("ProximityPrompt") then return end
	if prompt:GetAttribute("HasFake") then return end
	prompt:SetAttribute("HasFake", true)
	local fake = prompt:Clone()
	fake.Name = "FakePrompt"
	fake.Parent = prompt.Parent
	fake.Enabled = true
	fake.ClickablePrompt = true
	prompt.Enabled = false
	prompt.ClickablePrompt = false

	fake.Triggered:Connect(function()
		local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if not tool then return end

		
			dropRemote:FireServer(tool)
		

		local con
		con = Workspace.Drops.ChildAdded:Connect(function(v)
			local p = v:FindFirstChildOfClass("ProximityPrompt")
			if p then
				if mode == "Lockpick" then
					fireInteract(p)
					fireInteract(prompt)
				elseif mode == "Shears" then
					fireInteract(prompt)
					fireInteract(p)
				end

				task.wait(0.3)
				con:Disconnect()
			end
		end)
	end)
end

local function scanPrompts(validParents, validNames)
	local t = {}
	for _, v in ipairs(Workspace.CurrentRooms:GetDescendants()) do
		if v:IsA("ProximityPrompt") and (validParents[v.Parent.Name] or validNames[v.Name]) then
			table.insert(t, v)
		end
	end
	return t
end

 function cleanupEnableReal()
	for _, v in ipairs(Workspace.CurrentRooms:GetDescendants()) do
		if v.Name == "FakePrompt" and v.Parent then
			v:Destroy()
		end
		if v:IsA("ProximityPrompt") and v.Name ~= "FakePrompt" then
			pcall(function()
				v.Enabled = true
				v.ClickablePrompt = true
if v:GetAttribute("HasFake") == true then

v:SetAttribute("HasFake",nil)

end

			end)
		end
	end
end

 LockpickParents = { ChestBoxLocked = true, Locker_Small_Locked = true, Toolbox_Locked = true }
 LockpickNames = { UnlockPrompt = true, ThingToEnable = true, LockPrompt = true,
SkullPrompt = true, FusesPrompt = true }

 ShearsParents = { Chest_Vine = true, CuttableVines = true, Cellar = true }
 ShearsNames = { SkullPrompt = true }


local InfiniteValue = false
 InfStore = {}
local removed = false
Bypass:AddToggle('InfiniteItems', {
	Text = "Êó†ÈôêÊí¨ÈîÅÂô®/È™∑È´ÖÈí•Âåô",
Disabled = Disable3,
	Default = false,

	Callback = function(Value)
		InfiniteValue = Value
		if not InfiniteValue then
			cleanupEnableReal()
			InfStore = {}
			return
		end
		InfStore = scanPrompts(LockpickParents, LockpickNames)
	end
})

local InfiniteSValue = false
 InfSStore = {}
local removed2 = false

Bypass:AddToggle('InfiniteSItems', {
	Text = "Êó†ÈôêÂâ™ÂàÄ",
Disabled = Disable3,
	Default = false,
	Callback = function(Value)
		InfiniteSValue = Value
		if not InfiniteSValue then
			cleanupEnableReal()
			InfSStore = {}
			return
		end
		InfSStore = scanPrompts(ShearsParents, ShearsNames)
						
		
	end
})
end

Bypass:AddDivider()
if  ReplicatedStorage:FindFirstChild("RemotesFolder") then 

Bypass:AddDropdown("GMDropdown", {
        Values = { "Ëá™Âä®","ÂàáÊç¢"},
        Default = 2,
        Multi = false,

        Text = "‰∏äÂ∏ùÊ®°ÂºèÂàóË°®",
        

        Callback = function(Value)
               
        end,

        
})

local GodModeCameraHandler = {enabled = false}
local function GodModeCameraStep()
if not GodModeCameraHandler.enabled then return end
local cam = workspace.CurrentCamera
local char = LocalPlayer.Character
if not cam or not char or not char:FindFirstChild("HumanoidRootPart") then return end
local currentCF = cam.CFrame
local newPosition = Vector3.new(
currentCF.Position.X,
currentCF.Position.Y + 2.45,
currentCF.Position.Z
)
cam.CFrame = CFrame.new(newPosition, currentCF.Position + currentCF.LookVector * 10)
end
pcall(function() RunService:UnbindFromRenderStep("GOD_MODE_CAMERA_SYS") end)
RunService:BindToRenderStep("GOD_MODE_CAMERA_SYS", Enum.RenderPriority.Camera.Value+2, GodModeCameraStep)
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
if GodModeCameraHandler.enabled then
GodModeCameraHandler.enabled = false
task.wait(0.1)
GodModeCameraHandler.enabled = true
end
end)

Bypass:AddToggle('GodMode',{
Text = "‰∏äÂ∏ùÊ®°Âºè",
Default = false,
Callback = function(Value)
if Value then
if not Toggles.AntiHear.Value then
Toggles.AntiHear:SetValue(true)
Library:Notify("Ëá™Âä®ÂºÄÂêØÈò≤È£ûÂì•Âê¨ÂäõÂäüËÉΩÂè™ÊúâËøôÊ†∑‰∏äÂ∏ùÊ®°ÂºèÊâçËÉΩÂ∑•‰Ωú",3)
end
Character.Collision.Size = Vector3.new(1, 0.001, 5)
Character.Humanoid.HipHeight = 0.0001
GodModeCameraHandler.enabled = true
else
LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
Character.Collision.Size = Vector3.new(5.5, 3, 5)
Character.Humanoid.HipHeight = 2.4
GodModeCameraHandler.enabled = false
end
end
}):AddKeyPicker('GodmodeKeybind', {
    Default = 'G', 
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = '‰∏äÂ∏ùÊ®°Âºè',
    NoUI = false,
    Callback = function(Value)
    end,
    ChangedCallback = function(New)
    end
})

Bypass:AddDropdown("AnticheatManipulationMode", {
    Values = {"Áû¨Áßª", "ÂùêÊ†á", "ÁßªÂä®"},
    Default = "Áû¨Áßª",
    Multi = false,
    Text = "Á∫µËΩ¥Á©øÂ¢ôÊ®°Âºè",
    Callback = function(Value)
        if Toggles.AnticheatManipulation and Toggles.AnticheatManipulation.Value then
            Toggles.AnticheatManipulation:SetValue(false)
            task.wait(0.1)
            Toggles.AnticheatManipulation:SetValue(true)
        end
    end,
})

local AnticheatManipulationLoop = nil
local AnticheatManipulationOrigin = nil
local AnticheatManipulationEnabled = false
local OriginalNoclipState = false

Bypass:AddToggle('AnticheatManipulation',{
     Text = "Á∫µËΩ¥Á©øÂ¢ô",
     Default = false,
     Callback = function(Value)
        if Value then
            AnticheatManipulationEnabled = true
            
            if Options.AnticheatManipulationMode and Options.AnticheatManipulationMode.Value == "ÁßªÂä®" then
                OriginalNoclipState = Toggles.Noclip and Toggles.Noclip.Value or false
                if Toggles.Noclip then
                    Toggles.Noclip:SetValue(true)
                end
            end
            
            AnticheatManipulationLoop = task.spawn(function()
                while AnticheatManipulationEnabled and Toggles.AnticheatManipulation.Value do
                    if alive then
                        local character = LocalPlayer.Character
                        local humanoidRootPart = character.HumanoidRootPart
                        local lookVector = humanoidRootPart.CFrame.LookVector
                        
                        if Options.AnticheatManipulationMode and Options.AnticheatManipulationMode.Value == "Áû¨Áßª" then
                            if not AnticheatManipulationOrigin then
                                AnticheatManipulationOrigin = humanoidRootPart.Position
                            end
                            
                            local backwardPosition = humanoidRootPart.Position - lookVector * 10000
                            character:PivotTo(CFrame.new(backwardPosition))
                            task.wait(0.03)
                            
                            local forwardPosition = AnticheatManipulationOrigin + lookVector * 1
                            character:PivotTo(CFrame.new(forwardPosition))
                            
                            AnticheatManipulationOrigin = forwardPosition
                            task.wait(0.07)
                        elseif Options.AnticheatManipulationMode and Options.AnticheatManipulationMode.Value == "ÂùêÊ†á" then
                            local backwardPosition = humanoidRootPart.Position - (lookVector * 10000)
                            character:PivotTo(CFrame.new(backwardPosition))
                            task.wait(0.07)
                        else
                            local forwardPosition = humanoidRootPart.Position + (lookVector * 0.012)
                            character:PivotTo(CFrame.new(forwardPosition))
                            task.wait()
                        end
                    else
                        task.wait()
                    end
                end
                
                if alive and AnticheatManipulationOrigin and Options.AnticheatManipulationMode and Options.AnticheatManipulationMode.Value == "Áû¨Áßª" then
                    character:PivotTo(CFrame.new(AnticheatManipulationOrigin))
                end
            end)
        else
            AnticheatManipulationEnabled = false
            
            if AnticheatManipulationLoop then
                task.cancel(AnticheatManipulationLoop)
                AnticheatManipulationLoop = nil
            end
            
            if Options.AnticheatManipulationMode and Options.AnticheatManipulationMode.Value == "ÁßªÂä®" and Toggles.Noclip then
                Toggles.Noclip:SetValue(OriginalNoclipState)
            end
            
            if alive and AnticheatManipulationOrigin and Options.AnticheatManipulationMode and Options.AnticheatManipulationMode.Value == "Áû¨Áßª" then
                LocalPlayer.Character:PivotTo(CFrame.new(AnticheatManipulationOrigin))
            end
            
            AnticheatManipulationOrigin = nil
        end
     end
}):AddKeyPicker('AnticheatManipulationKeybind', {
    Default = 'H',
    SyncToggleState = true,
    Mode = 'Toggle',
    Text = 'Á∫µËΩ¥Á©øÂ¢ô',
    NoUI = false,
    Callback = function(Value)
    end,
    ChangedCallback = function(New)
    end
})

Bypass:AddButton({
	Text = "ÂêØÁî®ÈªÑËâ≤Ë£ÇÁºù",
	Func = function()
		local Event = game:GetService("ReplicatedStorage").ReplicaRemoteEvents.Replica_ReplicaSetValue
		firesignal(Event.OnClientEvent, 
			2,
			{
				"StarRiftItem"
			},
			{
				Exists = true
			}
		)
		Library:Notify("ÈªÑËâ≤Ë£ÇÁºùÂ∑≤ÂêØÁî®", 3)
	end
})


FloorAnti:AddToggle('RankedAntiBanana',{
     Text = "Èò≤ Nanner È¶ôËïâ",
     Default = false,
Callback = function(Value)
for _, v in ipairs(workspace:GetChildren()) do
if v.Name == "NannerPeel"  then
v.CanTouch = not Value
v:WaitForChild("Hitbox",9e9).CanTouch = not Value
end
end
end
})

FakeSurge = Instance.new("RemoteEvent",ReplicatedStorage)
FakeSurge.Name = "SurgeRemote"

FloorAnti:AddToggle('AntiSurge',{
     Text = "Èò≤ Surge",
     Default = false,
    Callback = function(Value)
if Value then

ReplicatedStorage.RemotesFolder.SurgeRemote.Parent = ReplicatedStorage
FakeSurge.Parent = ReplicatedStorage.RemotesFolder

else

ReplicatedStorage.RemotesFolder.SurgeRemote.Parent = ReplicatedStorage.RemotesFolder
FakeSurge.Parent = ReplicatedStorage


end

end
})

if Floor.Value == "Hotel" then
    local noPuzzleDoorsRunning = false
    local noPuzzleDoorsConnection = nil
    
    FloorAnti:AddToggle('NoPuzzleDoors', {
        Text = "Êó†Ë∞úÈ¢òÈó®",
        Default = false,
        Callback = function(Value)
            if Value then
                noPuzzleDoorsRunning = true
                
                for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
                    local movingDoor = room:FindFirstChild("MovingDoor", true)
                    if movingDoor then
                        movingDoor:Destroy()
                    end
                end
                
                noPuzzleDoorsConnection = RunService.Heartbeat:Connect(function()
                    if not noPuzzleDoorsRunning then return end
                    
                    for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
                        local movingDoor = room:FindFirstChild("MovingDoor", true)
                        if movingDoor then
                            movingDoor:Destroy()
                        end
                    end
                end)
                
                workspace.CurrentRooms.ChildAdded:Connect(function(room)
                    if not noPuzzleDoorsRunning then return end
                    task.wait(0.5)
                    
                    local movingDoor = room:FindFirstChild("MovingDoor", true)
                    if movingDoor then
                        movingDoor:Destroy()
                    end
                end)
                
            else
                noPuzzleDoorsRunning = false
                if noPuzzleDoorsConnection then
                    noPuzzleDoorsConnection:Disconnect()
                    noPuzzleDoorsConnection = nil
                end
            end
        end
    })
end

FloorAnti:AddDivider()


FloorAnti:AddToggle('AntiSeekObstructions',{
     Text = "Èò≤ËøΩÈÄêÈöúÁ¢ç",
     Default = false,
Callback = function(Value)
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "ChandelierObstruction" or v.Name == "Seek_Arm" then
for _, part in ipairs(v:GetChildren()) do
if part:IsA("BasePart") then part.CanTouch = not Value
end
end
end
end
end
})

if Floor.Value == "Mines" then

local PlayerGui = LocalPlayer.PlayerGui
    local MainUI = PlayerGui.MainUI
    

    local NotifyCodeValue = false

    FloorAuto:AddToggle("NotifyAnchorCode", {
        Text = "ÈÄöÁü•ÂØÜÁ†ÅÊú∫ÂØÜÁ†Å",
        Default = false,
        Callback = function(enabled)
local AnchorHintFrame = MainUI:WaitForChild("AnchorHintFrame")
            NotifyCodeValue = enabled
            while NotifyCodeValue do
                task.wait(0.9)

                local foundAnchor = nil
                local anchorSignText = AnchorHintFrame.AnchorCode.Text
                local currentCode = AnchorHintFrame.Code.Text

                
                for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                    if v.Name == "MinesAnchor" and v.Sign.TextLabel.Text == anchorSignText then
                        foundAnchor = v
                        break
                    end
                end

                if not foundAnchor then
                    task.wait()
                end
if foundAnchor then
                local noteObj = foundAnchor:FindFirstChild("Note")
                if not noteObj then
                    Library:Notify(("Èîö %s ÂØÜÁ†ÅÊòØ %s"):format(foundAnchor.Sign.TextLabel.Text, currentCode), 3)
                else
                    local noteText = noteObj.SurfaceGui.TextLabel.Text
                    local change = tonumber(noteText) or 0
                    local newcode = ""

                    for i = 1, #currentCode do
                        local num = tonumber(currentCode:sub(i, i)) or 0
                        num = (num + change) % 10
                        newcode = newcode .. num
                    end

                    Library:Notify(("Èîö %s ÂØÜÁ†ÅÊòØ %s"):format(foundAnchor.Sign.TextLabel.Text, newcode), 1)
                end
            end
        end
end
    })

FloorAnti:AddToggle('DeleteFigure',{
     Text = "Âà†Èô§È£ûÂì•",
     Default = false,
Disabled = Disable2
})
FloorAnti:AddDivider()
local clones = {}
		local bridgeConns = {}

		local function makeBarrier(barrier)
			if barrier.Parent:FindFirstChild("AntiBridge") then return end
			local clone = barrier:Clone()
			clone.Name = "AntiBridge"
			clone.Size = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
			clone.Color = Color3.new(1,1,1)
			clone.CFrame = barrier.CFrame * CFrame.new(0, 0, -5)
			clone.Transparency = 0
			clone.Anchored = true
			clone.CanCollide = true
			clone.CanTouch = true
			clone.Parent = barrier.Parent
			table.insert(clones, clone)
		end

		local function processBridge(bridge)
			if bridge:FindFirstChild("AntiBridge") then return end
			for _, part in ipairs(bridge:GetChildren()) do
				if part.Name == "PlayerBarrier" and part.Size.Y == 2.75 and (part.Rotation.X % 180) == 0 then
					makeBarrier(part)
				end
			end
			local conn = bridge.ChildAdded:Connect(function(c)
				if c.Name == "PlayerBarrier" then
					makeBarrier(c)
				end
			end)
			table.insert(bridgeConns, conn)
		end

		FloorAnti:AddToggle("ABF", {
			Text = "Èò≤Ê≠¢Ê°•Âù†ÊØÅ",
			Default = false,
			Callback = function(on)
				for _, c in ipairs(bridgeConns) do c:Disconnect() end
				bridgeConns = {}
				for _, c in ipairs(clones) do if c and c.Parent then c:Destroy() end end
				clones = {}

				if not on then return end

				task.spawn(function()
					for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
						local parts = room:FindFirstChild("Parts")
						if parts then
							for _, obj in ipairs(parts:GetChildren()) do
								if obj.Name == "Bridge" then
									processBridge(obj)
								end
							end
							local conn = parts.ChildAdded:Connect(function(c)
								if c.Name == "Bridge" then
									processBridge(c)
								end
							end)
							table.insert(bridgeConns, conn)
						end
					end
				end)

				local roomConn = workspace.CurrentRooms.ChildAdded:Connect(function(room)
					task.defer(function()
						local parts = room:WaitForChild("Parts", 3)
						if parts then
							for _, obj in ipairs(parts:GetChildren()) do
								if obj.Name == "Bridge" then
									processBridge(obj)
								end
							end
							local conn = parts.ChildAdded:Connect(function(c)
								if c.Name == "Bridge" then
									processBridge(c)
								end
							end)
							table.insert(bridgeConns, conn)
						end
					end)
				end)
				table.insert(bridgeConns, roomConn)
			end
		})

FloorAuto:AddToggle('AnticheatBypass',{
     Text = "ÁªïËøáÂèç‰ΩúÂºä",
     Default = false
})
Toggles.AnticheatBypass:OnChanged(function(Value)
if not Value then

RemoteFolder.ClimbLadder:FireServer()

end
if Value then

Library:Notify("Áà¨‰∏äÊ¢ØÂ≠êÁªïËøáÂèç‰ΩúÂºä",9)

end

end)

LocalPlayer.Character:GetAttributeChangedSignal("Climbing"):Connect(function()
if LocalPlayer.Character:GetAttribute("Climbing") == true then
if Toggles.AnticheatBypass.Value then 
task.wait(0.4)
LocalPlayer.Character:SetAttribute("Climbing",false)
Library:Notify("ÁªïËøáÊàêÂäüÔºåËøáÂú∫Âä®ÁîªÂíåHalt‰ºöÁ†¥ÂùèÁªïËøá",7)
end

end


end)

end

if Floor.Value == "Mines" then
local autoAnchorRunning = false
local autoAnchorConnection = nil
local lastCheck = 0
local checkInterval = 0.5
local cachedAnchors = {}

local function updateAnchorCache()
cachedAnchors = {}
local room50 = workspace.CurrentRooms:FindFirstChild("50")
if not room50 then 
for roomName, room in pairs(workspace.CurrentRooms:GetChildren()) do
if tonumber(roomName) and tonumber(roomName) >= 50 then
room50 = room
break
end
end
end
if room50 then
for _, anchor in ipairs(room50:GetDescendants()) do
if anchor.Name == "MinesAnchor" then
table.insert(cachedAnchors, anchor)
end
end
end
end
local function solveAnchor()
if not autoAnchorRunning then return end
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local mainUI = playerGui:WaitForChild("MainUI")
local AnchorHintFrame = mainUI:FindFirstChild("AnchorHintFrame")
if not AnchorHintFrame then return end
local anchorSignText = AnchorHintFrame:FindFirstChild("AnchorCode")
local currentCode = AnchorHintFrame:FindFirstChild("Code")
if not anchorSignText or not currentCode then return end
local signText = anchorSignText.Text
local codeText = currentCode.Text
if signText == "" or codeText == "" then return end
local playerPosition = LocalPlayer.Character and 
LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and 
LocalPlayer.Character.HumanoidRootPart.Position
if not playerPosition then return end
for _, anchor in ipairs(cachedAnchors) do
if not autoAnchorRunning then break end
local sign = anchor:FindFirstChild("Sign")
if sign then
local textLabel = sign:FindFirstChild("TextLabel")
if textLabel and textLabel.Text == signText then
local anchorPosition = anchor.PrimaryPart and anchor.PrimaryPart.Position or
(anchor:FindFirstChildWhichIsA("BasePart") and anchor:FindFirstChildWhichIsA("BasePart").Position)
if anchorPosition then
local distance = (playerPosition - anchorPosition).Magnitude
if distance < 12 then
local anchorRemote = anchor:FindFirstChild("AnchorRemote")
if anchorRemote then
pcall(function()
anchorRemote:InvokeServer(codeText)
end)
end
break
end
end
end
end
end
end

Automation:AddToggle('AutoAnchorSolver', {
    Text = "Ëá™Âä®ÂØÜÁ†ÅÊú∫",
    Default = false,
Callback = function(Value)
if Value then
autoAnchorRunning = true
updateAnchorCache()
autoAnchorConnection = game:GetService("RunService").Heartbeat:Connect(function()
if not autoAnchorRunning then return end
local now = tick()
if now - lastCheck >= checkInterval then
lastCheck = now
solveAnchor()
end
end)
else
autoAnchorRunning = false
if autoAnchorConnection then
autoAnchorConnection:Disconnect()
autoAnchorConnection = nil
end
end
end
})
end

if Floor.Value == "Mines" then
local minecartRenameActive = false
local minecartToggleEnabled = false
local minecartRoomCheckConnection = nil

FloorAnti:AddToggle('DeleteMinecart', {
Text = "Âà†Èô§ÁüøËΩ¶",
Default = false,
Callback = function(Value)
minecartToggleEnabled = Value

if Value then
local room46 = workspace.CurrentRooms:FindFirstChild("46")
if room46 then
performMinecartRename()
else
minecartRoomCheckConnection = workspace.CurrentRooms.ChildAdded:Connect(function(child)
if child.Name == "46" and minecartToggleEnabled then
task.wait(1)
performMinecartRename()
if minecartRoomCheckConnection then
minecartRoomCheckConnection:Disconnect()
minecartRoomCheckConnection = nil
end
end
end)
end
else
if minecartRoomCheckConnection then
minecartRoomCheckConnection:Disconnect()
minecartRoomCheckConnection = nil
end

if not minecartRenameActive then
else
Toggles.DeleteMinecart:SetValue(true)
end
end
end
})

function performMinecartRename()
if minecartRenameActive then
return
end

minecartRenameActive = true

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RemotesFolder = ReplicatedStorage:WaitForChild("RemotesFolder")

local remoteNames = {"MinecartResult"}

for _, name in ipairs(remoteNames) do
local remote = RemotesFolder:FindFirstChild(name)
if remote then
remote.Name = name .. " "
end
end

Library:Notify("Âà†Èô§ÁüøËΩ¶ÊàêÂäü", 7)
Library:Notify("Ëß¶ÂèëÁüøËΩ¶ËøáÂú∫Âä®ÁîªÂêéÂèØÁªïËøáÂèç‰ΩúÂºä", 7)

Toggles.DeleteMinecart:SetValue(true)
end
    
if Toggles.DeleteMinecart and Toggles.DeleteMinecart.Value then
local room46 = workspace.CurrentRooms:FindFirstChild("46")
if room46 then
performMinecartRename()
end
end

FloorAnti:AddButton({
Text = "Á¶ÅÁî®ÂÆû‰Ωì",
DoubleClick = true,
Risky = true,
Func = function()
task.spawn(function()
for i = 1, 11 do
game.ReplicatedStorage.RemotesFolder.RequestAsset:InvokeServer("Remote")
task.wait(0.1)
end
end)
end
})
end

if Floor.Value == "Mines" then
    FloorAuto:AddToggle('MinecartNoCollision', {
        Text = "ÁüøËΩ¶Êó†Á¢∞Êíû",
        Default = false,
Callback = function(Value)
if Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local assets = room:FindFirstChild("Assets")
if assets then
local minecartSet = assets:FindFirstChild("MinecartSet")
if minecartSet then
for _, child in ipairs(minecartSet:GetChildren()) do
local cart = child:FindFirstChild("Cart")
if cart and cart:IsA("BasePart") then
cart.CanCollide = false
end
end
end
end
end
                
if not minecartConnection then
minecartConnection = workspace.DescendantAdded:Connect(function(descendant)
if Toggles.MinecartNoCollision and Toggles.MinecartNoCollision.Value then
if descendant.Name == "Cart" and descendant:IsA("BasePart") then
local parent = descendant.Parent
if parent and parent.Parent and parent.Parent.Name == "MinecartSet" then
descendant.CanCollide = false
end
end
end
end)
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local assets = room:FindFirstChild("Assets")
if assets then
local minecartSet = assets:FindFirstChild("MinecartSet")
if minecartSet then
for _, child in ipairs(minecartSet:GetChildren()) do
local cart = child:FindFirstChild("Cart")
if cart and cart:IsA("BasePart") then
cart.CanCollide = true
end
end
end
end
end

if minecartConnection then
minecartConnection:Disconnect()
minecartConnection = nil
end
end
end
})
    
local minecartConnection = nil

local SeekPathColor = Color3.new(0, 1, 0)
local SeekPathThickness = 0.2
local seekPathLines = {}
local seekPathUpdateConnection = nil

function updateSeekPathLines()
for _, line in ipairs(seekPathLines) do
if line and line.Parent then
line:Destroy()
end
end
seekPathLines = {}

local allLights = {}
for _, v in ipairs(workspace:GetDescendants()) do
if v.Name == "SeekGuidingLight" then
table.insert(allLights, v)
end
end

if #allLights < 2 then
return
end

for i = 1, #allLights - 1 do
local currentLight = allLights[i]
local nextLight = allLights[i + 1]
local distance = (currentLight.Position - nextLight.Position).Magnitude
local center = (currentLight.Position + nextLight.Position) / 2

local linePart = Instance.new("Part", Pathnode)
linePart.Name = "ShowPathLine"
linePart.Size = Vector3.new(SeekPathThickness, SeekPathThickness, distance)
linePart.CFrame = CFrame.lookAt(center, nextLight.Position)
linePart.Color = SeekPathColor
linePart.Material = Enum.Material.Neon
linePart.Anchored = true
linePart.CanCollide = false
linePart.CanTouch = false
linePart.CanQuery = false
linePart.Transparency = 0

table.insert(seekPathLines, linePart)

end
end

function clearSeekPathLines()
for _, line in ipairs(seekPathLines) do
if line and line.Parent then
line:Destroy()
end
end
seekPathLines = {}

if seekPathUpdateConnection then
seekPathUpdateConnection:Disconnect()
seekPathUpdateConnection = nil
end
end

FloorAuto:AddToggle("ShowSeekPath", {
    Text = "ÊòæÁ§∫ËøΩÈÄêÊàòË∑ØÂæÑ",
    Default = false,
Callback = function(Value)
if Value then
updateSeekPathLines()

seekPathUpdateConnection = RunService.Heartbeat:Connect(function()
if tick() % 0.5 < 0.016 then
updateSeekPathLines()
end
end)
else
clearSeekPathLines()
end
end
}):AddColorPicker('SeekPathColorPicker', {
    Default = SeekPathColor,
    Title = 'Ë∑ØÂæÑÈ¢úËâ≤',
    Transparency = 0,
Callback = function(Value)
SeekPathColor = Value
if Toggles.ShowSeekPath and Toggles.ShowSeekPath.Value then
updateSeekPathLines()
end
end
})

FloorAuto:AddSlider("SeekPathThicknessSlider", {
    Text = "Á∫ø‰ΩìÂéöÂ∫¶",
    Default = 0.2,
    Min = 0.1,
    Max = 1.0,
Rounding = 1,
Compact = true,
Callback = function(Value)
SeekPathThickness = Value
if Toggles.ShowSeekPath and Toggles.ShowSeekPath.Value then
updateSeekPathLines()
end
end
})
end

local RankedAntiBananaConnection = nil

RankedAntiBananaConnection = workspace.ChildAdded:Connect(function(v)
if Toggles.RankedAntiBanana and Toggles.RankedAntiBanana.Value then
if v.Name == "NannerPeel"  then
v.CanTouch = false
v:WaitForChild("Hitbox",9e9).CanTouch = false
end
end
end)


ModifiersBox:AddToggle('AntiLookman',{
     Text = "Èò≤ Lookman",
     Default = false
})

if Floor.Value == "Party" then
FloorAnti:AddToggle('AutoGetPowerUps',{
Text = "Ëá™Âä®Êé•ÈÄöÁîµÊ∫ê",
Default = false,
Callback = function(Value)

if Value then

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "PowerupPad" then
v:WaitForChild("Hitbox",9e9).Size = Vector3.new(90, 90, 90)
end 
end
else 
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "PowerupPad" then
v:WaitForChild("Hitbox",9e9).Size = Vector3.new(5, 5, 5)
end 
end
end

end
})
end




ModifiersBox:AddToggle('AntiGiggle',{
     Text = "Èò≤ Giggle",
     Default = false,
Callback = function(Value)
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "GiggleCeiling" then
v:WaitForChild("Hitbox",9e9).CanTouch = not Value

end
end

end 
})

ModifiersBox:AddToggle('AntiJam',{
     Text = "Èò≤ Jamming",
     Default = false,
Callback = function(Value)

if Modifiers and not Modifiers:FindFirstChild("Jammin") then return end
local mainTrack = game["SoundService"]:FindFirstChild("Main")
if mainTrack then
local jamming = mainTrack:FindFirstChild("Jamming")
if jamming then
jamming.Enabled = not Value
end
end

local mainUI = LocalPlayer:FindFirstChild("PlayerGui")
and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
if mainUI then
local healthGui = mainUI:FindFirstChild("Initiator")
and mainUI.Initiator:FindFirstChild("Main_Game")
and mainUI.Initiator.Main_Game:FindFirstChild("Health")
if healthGui then
local jamSound = healthGui:FindFirstChild("Jam")
if jamSound then
jamSound.Playing = not Value
end
end
end
end
})

ModifiersBox:AddToggle('AntiGloomPile',{
     Text = "Èò≤ Gloom Egg",
     Default = false,
Callback = function(Value)
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "GloomEgg" then
 v:WaitForChild("Egg",9e9).CanTouch = not Value
end
end
end 
})

ModifiersBox:AddToggle('AntiVacuum',{
     Text = "Èò≤ Vacuum",
     Default = false,
Callback = function(Value)
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "SideroomSpace" then
for _, part in ipairs(v:GetChildren()) do
if part:IsA("BasePart") then
part.CanTouch = not Value
part.CanCollide = Value
end
end
end
end
end 
})

ModifiersBox:AddToggle('AntiSeekFlood',{
     Text = "Èò≤ Seek Ê¥™Ê∞¥",
     Default = false,
Callback = function(Value)
local SeekSlopRemote = game:GetService("ReplicatedStorage").RemotesFolder:FindFirstChild("SeekSlop")
if SeekSlopRemote then
SeekSlopRemote.Name = Value and "_SeekSlop" or "SeekSlop"
end
end
})

local function isPlayerOwnedItem(instance)
local current = instance
while current and current ~= workspace do
if current:IsA("Model") then
local player = Players:GetPlayerFromCharacter(current)
if player and player == LocalPlayer then
return true
end
if current:IsA("Tool") then
local owner = current:FindFirstChild("Owner")
if owner and owner.Value then
return true
end
local parent = current.Parent
if parent and (parent:IsA("Backpack") or (parent:IsA("Model") and Players:GetPlayerFromCharacter(parent))) then
return true
end
end
end
current = current.Parent
end
return false
end

function AddESP(inst, txt, color)
if isPlayerOwnedItem(inst) then
return
end
    
if not inst or not inst.Parent then return end
    
local model = inst
if inst:IsA("BasePart") and inst.Parent and inst.Parent:IsA("Model") then
model = inst.Parent
end
    
if inst.Name == "Door" and inst.Parent and inst.Parent.Name == "Door" then
model = inst
end
    
if isPlayerOwnedItem(model) then
return
end
    
if ESPObjects[model] then
ESPObjects[model]:Hide()
end
    
local espObject = ESPLibrary:Add({
Name = txt,
Model = model,
Color = color,
MaxDistance = 1000,
TextSize = ESPConfig.TextSize,
ESPType = ESPConfig.ESPType,
FillColor = color,
OutlineColor = color,
FillTransparency = ESPConfig.FillTransparency,
OutlineTransparency = ESPConfig.OutlineTransparency,
Tracer = { 
Enabled = ESPConfig.Tracer.Enabled,
Color = color,
From = ESPConfig.Tracer.Position
}
})
    
ESPObjects[model] = espObject
espObject:Show()
end

function ESPLibrary:AddESP(Part, Txt, Color)
if isPlayerOwnedItem(Part) then
return
end
    
if not Part or not Part.Parent then return end
    
local model = Part
if Part:IsA("BasePart") and Part.Parent and Part.Parent:IsA("Model") then
model = Part.Parent
end
    
if Part.Name == "Door" and Part.Parent and Part.Parent.Name == "Door" then
model = Part
end
    
if isPlayerOwnedItem(model) then
return
end
    
if ESPObjects[model] then
ESPObjects[model]:Hide()
end
    
local espObject = ESPLibrary:Add({
Name = Txt,
Model = model,
Color = Color,
MaxDistance = 1000,
TextSize = ESPConfig.TextSize,
ESPType = "Highlight",
FillColor = Color,
OutlineColor = Color,
FillTransparency = ESPConfig.FillTransparency,
OutlineTransparency = ESPConfig.OutlineTransparency,
Tracer = { 
Enabled = ESPConfig.Tracer.Enabled,
Color = Color,
From = ESPConfig.Tracer.Position
}
})
    
ESPObjects[model] = espObject
espObject:Show()
end


local DoorColor = Color3.new(0,1,1)
local PlayersColor = Color3.new(1, 1, 1)
local EntityColor = Color3.new(1, 0, 0)
local HidingSpotColor = Color3.new(0,0.5,0)
local ItemsColor = Color3.new(1,0,1)
local ChestColor = Color3.new(1, 0.8, 0)
local GoldColor = Color3.new(1, 0.8, 0)
local StardustColor = Color3.fromRGB(230, 116, 126)
local TaskColor = Color3.new(0, 1, 0)
local LadderColor = Color3.new(0, 0, 1)

ESP:AddToggle('Door',{
     Text = "Èó®",
     Default = false,
Callback = function(Value)
if Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local roomNumber = tonumber(room.Name)
if roomNumber and shouldShowESP(roomNumber) then
if room:FindFirstChild("Door") and room.Door:FindFirstChild("Door") then
local Door = room.Door.Door
if not Door:GetAttribute("Used") then
local displayText = "Èó® " .. Door.Parent:GetAttribute("RoomID")
local currentRoom = LocalPlayer:GetAttribute("CurrentRoom")
local isLocked = false
local isOpen = not Door.Anchored

if roomNumber == currentRoom then
if Door.Parent:FindFirstChild("Lock") then
isLocked = true
end
elseif roomNumber == currentRoom + 1 then
local keyFound = false
for _, obj in ipairs(room:GetDescendants()) do
if obj.Name == "KeyObtain" and not obj:GetAttribute("Used") then
keyFound = true
break
end
end
if keyFound then
isLocked = true
end
end

if isOpen then
displayText = "[Â∑≤ÊâìÂºÄ] " .. displayText
else
if isLocked then
displayText = "[ÈîÅÂÆö] " .. displayText
end
end

AddESP(Door, displayText, DoorColor)
end
end
end
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
if room:FindFirstChild("Door") and room.Door:FindFirstChild("Door") then
ESPLibrary:RemoveESP(room.Door.Door)
end
end
end
end
}):AddColorPicker('DoorColo', {
	Default = DoorColor,
	Title = 'Èó®È¢úËâ≤',
	Transparency = 0,

Callback = function(Value)
DoorColor = Value
if Toggles.Door.Value then

Toggles.Door:SetValue(false)
Toggles.Door:SetValue(true)

end
end
})

ESP:AddToggle('TaskESP',{
Text = "‰ªªÂä°",
Default = false,
Callback = function(Value)
if Value then
local currentRoom = LocalPlayer:GetAttribute("CurrentRoom")
if not currentRoom then return end
    
local roomsToCheck = {currentRoom, currentRoom + 1}
    
for _, roomNumber in ipairs(roomsToCheck) do
local room = workspace.CurrentRooms:FindFirstChild(tostring(roomNumber))
if room then
local v = room:FindFirstChild("KeyObtain", true)
if v and not v:GetAttribute("Used") then
AddESP(v,"Èí•Âåô",TaskColor)
end

if Floor.Value == "Mines" then
for _, fuse in ipairs(room:GetDescendants()) do
if fuse.Name == "FuseObtain" then
AddESP(fuse,"‰øùÈô©‰∏ù",TaskColor)
end
end
end

if roomNumber == currentRoom then
for _, book in ipairs(room:GetDescendants()) do
if book.Name == "LiveHintBook" then
AddESP(book,"‰π¶",TaskColor)
end
end
end

if roomNumber == currentRoom then
for _, breaker in ipairs(room:GetDescendants()) do
if breaker.Name == "LiveBreakerPolePickup" then
AddESP(breaker,"Êñ≠Ë∑ØÂô®",TaskColor)
end
end
end

if Floor.Value == "Mines" then
for _, anchor in ipairs(room:GetDescendants()) do
if anchor.Name == "MinesAnchor" then
AddESP(anchor,"Èîö " .. anchor:WaitForChild("Sign").TextLabel.Text,TaskColor)
end
end
end

if Floor.Value == "Mines" then
for _, generator in ipairs(room:GetDescendants()) do
if generator.Name == "GeneratorMain" then
AddESP(generator,"ÂèëÁîµÊú∫",TaskColor)
end
end
end


if Floor.Value == "Mines" and roomNumber == currentRoom then
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "MinesGateButton" then
AddESP(v, "Èó®ÊåâÈíÆ", TaskColor)
end
end
end

if Floor.Value == "Mines" then
for _, pump in ipairs(room:GetDescendants()) do
if pump.Name == "WaterPump" then
AddESP(pump,"Ê∞¥Ê≥µ",TaskColor)
end
end
end

local timerLever = room:FindFirstChild("TimerLever", true)
if timerLever and timerLever.Name == "TimerLever" then
AddESP(timerLever,"ÂÄíËÆ°Êó∂ÊãâÊùÜ",TaskColor)
end

for _, lever in ipairs(room:GetDescendants()) do
if lever.Name == "LeverForGate" then
AddESP(lever,"Èó®ÊãâÊùÜ",TaskColor)
end
end

if Floor.Value == "Garden" and roomNumber == currentRoom then
for _, v in ipairs(room:GetDescendants()) do
if v and v.Parent and v.Parent.Name == "VineGuillotine" and v.Name == "Lever" then
AddESP(v,"ÊãâÊùÜ",TaskColor)
end
end
end
end
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local Key = room:FindFirstChild("KeyObtain",true)
if Key then ESPLibrary:RemoveESP(Key) end
local TimerLever = room:FindFirstChild("TimerLever",true)
if TimerLever then ESPLibrary:RemoveESP(TimerLever) end
local GateLever = room:FindFirstChild("LeverForGate",true)
if GateLever then ESPLibrary:RemoveESP(GateLever) end
end

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "FuseObtain" then
ESPLibrary:RemoveESP(v)
end
end

for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "LiveHintBook" then
ESPLibrary:RemoveESP(v)
end
end
end

for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "LiveBreakerPolePickup" then
ESPLibrary:RemoveESP(v)
end
end
end

if Floor.Value == "Mines" then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "MinesAnchor" or v.Name == "GeneratorMain" or v.Name == "WaterPump" then
ESPLibrary:RemoveESP(v)
end
end
end

if Floor.Value == "Mines" then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "MinesGateButton" then
ESPLibrary:RemoveESP(v)
end
end
end
end

if Floor.Value == "Garden" then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v and v.Parent and v.Parent.Name == "VineGuillotine" and v.Name == "Lever" then
ESPLibrary:RemoveESP(v)
end
end
end
end
end
end
}):AddColorPicker('TaskColor', {
Default = TaskColor,
Title = '‰ªªÂä°È¢úËâ≤',
Transparency = 0,
Callback = function(Value)
TaskColor = Value
if Toggles.TaskESP.Value then
Toggles.TaskESP:SetValue(false)
Toggles.TaskESP:SetValue(true)
end
end
})

if Floor.Value == "Mines" then
ESP:AddToggle('Ladder',{
Text = "Ê¢ØÂ≠ê",
Default = false,
Callback = function(Value)
if Value then
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Ladder" then
AddESP(v, "Ê¢ØÂ≠ê", LadderColor)
end
end
else
for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Ladder" then
ESPLibrary:RemoveESP(v)
end
end
end
end
}):AddColorPicker('LadderColor', {
Default = LadderColor,
Title = 'Ê¢ØÂ≠êÈ¢úËâ≤',
Transparency = 0,
Callback = function(Value)
LadderColor = Value
if Toggles.Ladder and Toggles.Ladder.Value then
Toggles.Ladder:SetValue(false)
Toggles.Ladder:SetValue(true)
end
end
})
end

local HidingSpots = {
Wardrobe = "ÊüúÂ≠ê",
Rooms_Locker = "ÊüúÂ≠ê",
Backdoor_Wardrobe = "ÊüúÂ≠ê",
Toolshed = "ÊüúÂ≠ê",
Locker_Large = "ÊüúÂ≠ê",
Bed = "Â∫ä",
CircularVent = "ÈÄöÈ£éÂè£",
Rooms_Locker_Fridge = "ÂÜ∞ÁÆ±",
RetroWardrobe = "ÊüúÂ≠ê",
Dumpster = "ÂûÉÂúæÊ°∂",
Double_Bed = "Â∫ä"
}

ESP:AddToggle('HidingSpot',{
     Text = "Ë∫≤ËóèÁÇπ",
     Default = false,
Callback = function(Value)
if Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local roomNumber = tonumber(room.Name)
if roomNumber and shouldShowESP(roomNumber) then
local assets = room:FindFirstChild("Assets")
if assets then
for _, v in ipairs(assets:GetChildren()) do
local TextName = HidingSpots[v.Name]
if TextName and v.PrimaryPart then
AddESP(v,TextName,HidingSpotColor)
end
end
end
end
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local assets = room:FindFirstChild("Assets")
if assets then
for _, v in ipairs(assets:GetChildren()) do
local TextName = HidingSpots[v.Name]
if TextName and v.PrimaryPart then
ESPLibrary:RemoveESP(v)
end
end
end
end
end
end
}):AddColorPicker('HidingSpot', {
	Default = HidingSpotColor,
	Title = 'Ë∫≤ËóèÁÇπÈ¢úËâ≤',
	Transparency = 0,

Callback = function(Value)
HidingSpotColor = Value
if Toggles.HidingSpot.Value then

Toggles.HidingSpot:SetValue(false)
Toggles.HidingSpot:SetValue(true)

end
end
})

ESP:AddToggle('Players',{
     Text = "Áé©ÂÆ∂",
     Default = false,
Callback = function(Value)
if Value then
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= LocalPlayer and plr.Character then
AddESP(plr.Character,plr.Name,PlayersColor)

end
end
else
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= LocalPlayer and plr.Character then
ESPLibrary:RemoveESP(plr.Character)
end
end

end
end
}):AddColorPicker('PlayersColo', {
	Default = PlayersColor,
	Title = 'Áé©ÂÆ∂È¢úËâ≤',
	Transparency = 0,

Callback = function(Value)
PlayersColor = Value
if Toggles.Players.Value then

Toggles.Players:SetValue(false)
Toggles.Players:SetValue(true)

end
end
})

local PlayersConnection
for _, v in ipairs(Players:GetPlayers()) do
PlayersConnection = v.CharacterAdded:Connect(function()
for _, plr in ipairs(Players:GetPlayers()) do
if plr ~= LocalPlayer and plr.Character then
AddESP(plr.Character,plr.Name,PlayersColor)
end
end

end)
end

 Item = {
Flashlight = "ÊâãÁîµÁ≠í",
Lockpick = "Êí¨ÈîÅÂô®",
Vitamins = "Áª¥ÁîüÁ¥†",
Bandage = "ÂàõÂè£Ë¥¥",
StarVial = "Â∞èÊòüÁì∂",
StarBottle = "ÊòüÁì∂",
StarJug = "ÊòüÁΩê",
Shakelight = "ÊâãÊëáÁîµÁ≠í",
Straplight = "ËÉåÂ∏¶ÁÅØ",
Bulklight = "Êï£Ë£ÖÁÅØ",
Battery = "ÁîµÊ±†",
Candle = "Ëú°ÁÉõ",
Crucifix = "ÂçÅÂ≠óÊû∂",
CrucifixWall = "ÂçÅÂ≠óÊû∂",
Glowsticks = "ËçßÂÖâÊ£í",
SkeletonKey = "È™∑È´ÖÈí•Âåô",
Candy = "Á≥ñÊûú",
ShieldMini = "Ëø∑‰Ω†ÁõæÁâå",
ShieldBig = "Â§ßÁõæÁâå",
BandagePack = "ÂàõÂè£Ë¥¥ÂåÖË£ÖÁõí",
BatteryPack = "ÁîµÊ±†ÂåÖË£ÖÁõí",
RiftCandle = "ÊúàÂÖâËú°ÁÉõ",
LaserPointer = "ÊøÄÂÖâÁ¨î",
HolyGrenade = "Á•ûÂú£ÊâãÈõ∑",
Shears = "Ââ™ÂàÄ",
Smoothie = "Â•∂Êòî",
Cheese = "Â•∂ÈÖ™",
Bread = "Èù¢ÂåÖ",
AlarmClock = "ÈóπÈíü",
RiftSmoothie = "ÊúàÂÖâÂ•∂Êòî",
GweenSoda = "ËãèÊâìÊ∞¥",
GlitchCube = "ÊïÖÈöúÊñπÂùó",
RiftJar = "Ë£ÇÁºùÁΩê",
Compass = "ÁΩóÁõò",
Lantern = "ÊâãÊèêÁÅØ",
Multitool = "‰∏áËÉΩÂ∑•ÂÖ∑",
Lotus = "Ëé≤Ëä±",
TipJar = "Â∞èË¥πÁΩê",
LotusPetalPickup = "Ëé≤Ëä±Ëä±Áì£",
KeyIron = "ÈìÅÈí•Âåô",
CandyBag = "Á≥ñÊûúË¢ãÂ≠ê",
Donut = "ÁîúÁîúÂúà"

}
ESP:AddToggle('Items',{
     Text = "Áâ©ÂìÅ",
     Default = false,
Callback = function(Value)
if Value then
for _, i in ipairs(workspace.CurrentRooms:GetDescendants()) do
local name = Item[i.Name]
if name and i.PrimaryPart then
AddESP(i,name,ItemsColor)

end
end
else
for _, i in ipairs(workspace.CurrentRooms:GetDescendants()) do
local name = Item[i.Name]
if name and i.PrimaryPart then
ESPLibrary:RemoveESP(i)
end
end

end
end
}):AddColorPicker('ItemsColo', {
	Default = ItemsColor,
	Title = 'Áâ©ÂìÅÈÄèËßÜ',
	Transparency = 0,

Callback = function(Value)
ItemsColor = Value
if Toggles.Items.Value then
Toggles.Items:SetValue(false)
Toggles.Items:SetValue(true)
end
end
})

ESP:AddToggle('Chest',{
     Text = "ÁÆ±Â≠ê",
     Default = false,
Callback = function(Value)
if Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local roomNumber = tonumber(room.Name)
if roomNumber and shouldShowESP(roomNumber) then
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "Toolshed_Small" or v.Name == "Chest_Vine" or v.Name == "ChestBoxLocked" or v.Name == "ChestBox" then
local displayText = "ÁÆ±Â≠ê"
if v.Name == "Chest_Vine" then
displayText = "[Ëó§Ëîì] ÁÆ±Â≠ê"
elseif v.Name == "ChestBoxLocked" then
displayText = "[ÈîÅÂÆö] ÁÆ±Â≠ê"
elseif v.Name == "Toolshed_Small" then
displayText = "Ââ™ÂàÄÊüúÂ≠ê"
end
AddESP(v, displayText, ChestColor)
end
end
end
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "Toolshed_Small" or v.Name == "Chest_Vine" or v.Name == "ChestBoxLocked" or v.Name == "ChestBox" then
ESPLibrary:RemoveESP(v)
end
end
end
end
end
}):AddColorPicker('ChestColo', {
	Default = ChestColor,
	Title = 'ÁÆ±Â≠êÈ¢úËâ≤',
	Transparency = 0,

Callback = function(Value)
ChestColor = Value
if Toggles.Chest.Value then
Toggles.Chest:SetValue(false)
Toggles.Chest:SetValue(true)
end
end
})

ESP:AddToggle('Gold',{
     Text = "ÈáëÂ∏Å",
     Default = false,
Callback = function(Value)
if Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local roomNumber = tonumber(room.Name)
if roomNumber and shouldShowESP(roomNumber) then
for _, v in ipairs(room:GetDescendants()) do
if v and v.Name == "GoldPile" then
AddESP(v,"ÈáëÂ∏Å " .. v:GetAttribute("GoldValue"),GoldColor)
end
end
end
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "GoldPile" then
ESPLibrary:RemoveESP(v)
end
end
end
end
end
}):AddColorPicker('GoldColor', {
	Default = GoldColor,
	Title = 'ÈáëÂ∏ÅÈ¢úËâ≤',
	Transparency = 0,

Callback = function(Value)
GoldColor = Value
if Toggles.Gold.Value then

Toggles.Gold:SetValue(false)
Toggles.Gold:SetValue(true)

end
end
})

ESP:AddToggle('Stardust',{
     Text = "ÊòüÂ∞ò",
     Default = false,
Callback = function(Value)
if Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local roomNumber = tonumber(room.Name)
if roomNumber and shouldShowESP(roomNumber) then
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "StardustPickup" then
AddESP(v, "ÊòüÂ∞ò", StardustColor)
end
end
end
end
else
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
for _, v in ipairs(room:GetDescendants()) do
if v.Name == "StardustPickup" then
ESPLibrary:RemoveESP(v)
end
end
end
end
end
}):AddColorPicker('StardustColo', {
	Default = StardustColor,
	Title = 'ÊòüÂ∞òÈ¢úËâ≤',
	Transparency = 0,

Callback = function(Value)
StardustColor = Value
if Toggles.Stardust.Value then
Toggles.Stardust:SetValue(false)
Toggles.Stardust:SetValue(true)
end
end
})

ESP:AddToggle('EntitesESP',{
     Text = "ÂÆû‰Ωì",
     Default = false
}):AddColorPicker('EntityColorPicker', {
	Default = EntityColor,
	Title = 'ÂÆû‰ΩìÈ¢úËâ≤',
	Transparency = 0,
Callback = function(Value)
EntityColor = Value
if Toggles.EntitesESP.Value then
for _, entity in ipairs(workspace:GetChildren()) do
if entity:FindFirstChild("ESP_System") then
entity.ESP_System.FillColor = EntityColor
if entity:FindFirstChild("ESP_GUI") and entity.ESP_GUI:FindFirstChild("Txt") then
entity.ESP_GUI.Txt.TextColor3 = EntityColor
end
end
end
end
end
})

table.insert(Connections,UserInputService.JumpRequest:Connect(function()
task.wait(0.3)
if Toggles.InfiniteJump.Value then
if Character then

Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

end
end

end)
)

table.insert(Connections,LocalPlayer.CharacterAdded:Connect(function()
task.wait(2)
Library:Notify("ËÆæÁΩÆÊâÄÊúâ",4)

if Toggles.EnableJump.Value then
LocalPlayer.Character:SetAttribute("CanJump",true)
end



if Toggles.Godmode.Value then

LocalPlayer.Character.Collision.Position = LocalPlayer.Character.Collision.Position - Vector3.new(0, 11, 0)


end
task.wait(3)
MainGame = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainUI"):WaitForChild("Initiator").Main_Game
 RequiredMainGame = require(LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game)
 RemoteListener = MainGame.RemoteListener
 Modules = RemoteListener.Modules

if Toggles.AntiScreech.Value then

local Screech = Modules:FindFirstChild("Screech") or Modules:FindFirstChild("_Screech")
Screech.Name = "_Screech"
end

if Toggles.SpeedBoost.Value and Floor.Value == "Mines" then
local currentSpeed = Speed
if LocalPlayer.Character:GetAttribute("Climbing") then
currentSpeed = currentSpeed + Options.LadderSpeedBoost.Value
end
LocalPlayer.Character.Humanoid.WalkSpeed = currentSpeed
end

if Toggles.AntiA90.Value then

local A90 = Modules:FindFirstChild("A90") or Modules:FindFirstChild("_A90")
if A90 then
A90.Name =   "_A90"


end

end

end))
function addESP(entity,label)

local base 
while entity.PrimaryPart == nil do
base = entity:FindFirstChildWhichIsA("BasePart")
task.wait()
end
base = entity.PrimaryPart


if not entity:FindFirstChildOfClass("Humanoid") then
Instance.new("Humanoid",entity)
end
if base then
base.Transparency = 0.99
end
ESPLibrary:AddESP(entity,label,EntityColor)
end

Toggles.EntityNotifys:OnChanged(function(Value)

if Value then
for _, v in ipairs(workspace:GetChildren()) do
if v.Name == "RushMoving" and Options.EntitiesPicker.Value["Rush"] then
Notify("Rush Â∑≤ÁîüÊàê",3)
Sound()
end
if v.Name == "BackdoorRush" and Options.EntitiesPicker.Value["Blitz"] then
Notify("Blitz Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "BackdoorLookman" and Options.EntitiesPicker.Value["Lookman"] then
Notify("Lookman Â∑≤ÁîüÊàê", 3)
Sound()
end

if v.Name == "AmbushMoving" and Options.EntitiesPicker.Value["Ambush"] then
Notify("Ambush Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "A60" and Options.EntitiesPicker.Value["A-60"] then
Notify("A-60 Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "A120" and Options.EntitiesPicker.Value["A-120"] then
Notify("A-120 Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "Eyes" and Options.EntitiesPicker.Value["Eyes"] then
Notify("Eyes Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "GlitchRush" and Options.EntitiesPicker.Value["GlitchRush"] then
Notify("GlitchRush Â∑≤ÁîüÊàê",3)
Sound()
end
if v.Name == "GlitchAmbush" and Options.EntitiesPicker.Value["GlitchAmbush"] then
Notify("GlitchAmbush Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "Groundskeeper" and Options.EntitiesPicker.Value["Groundskeeper"] then
Notify("Groundskeeper Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "MonumentEntity" and Options.EntitiesPicker.Value["Monument"] then
Notify("Monument Â∑≤ÁîüÊàê",3)
Sound()
end

end
if Toggles.EntitesESP.Value then
if v.Name == "RushMoving" then
addESP(v,"Rush")
end

if v.Name == "AmbushMoving" then
addESP(v,"Ambush")
end

if v.Name == "A60" then
addESP(v,"A-60")
end

if v.Name == "A120" then
addESP(v,"A-120")
end

if v.Name == "Eyes" then
addESP(v,"Eyes")
end

if v.Name == "BackdoorLookman" then
addESP(v,"Lookman")
end

if v.Name == "Groundskeeper" then
addESP(v, "Groundskeeper")
end

if v.Name == "MonumentEntity" then
addESP(v:WaitForChild("Top"),"Monument")
end
end
end

end)

table.insert(Connections,workspace.ChildAdded:Connect(function(v)
if  Toggles.EntityNotifys.Value then  
if v.Name == "RushMoving" and Options.EntitiesPicker.Value["Rush"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Rush",
Desc = "Rush Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://11102256553",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("Rush Â∑≤ÁîüÊàê", 3)
Sound()
end
end
if v.Name == "BackdoorRush" and Options.EntitiesPicker.Value["Blitz"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Blitz",
Desc = "Blitz Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://140595207306444",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("Blitz Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "BackdoorLookman" and Options.EntitiesPicker.Value["Lookman"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Lookman",
Desc = "Lookman Â∑≤ÁîüÊàê",
Reason = "‰∏çË¶ÅÁõ¥ËßÜÂÆÉ",
Image = "rbxassetid://16764872677",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("Lookman Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "AmbushMoving" and Options.EntitiesPicker.Value["Ambush"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Ambush",
Desc = "Ambush Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://10938726652",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("Ambush Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "A60" and Options.EntitiesPicker.Value["A-60"] then
if OptionNotify == "Doors" then
Achievement({
Title = "A-60",
Desc = "A-60 Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://12350986086",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("A-60 Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "A120" and Options.EntitiesPicker.Value["A-120"] then
if OptionNotify == "Doors" then
Achievement({
Title = "A-120",
Desc = "A-120 Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://12351008553",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("A-120 Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "Eyes" and Options.EntitiesPicker.Value["Eyes"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Eyes",
Desc = "Eyes Â∑≤ÁîüÊàê",
Reason = "‰∏çË¶ÅÁõ¥ËßÜÂÆÉ",
Image = "rbxassetid://10865377903",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("Eyes Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "GlitchRush" and Options.EntitiesPicker.Value["GlitchRush"] then
if OptionNotify == "Doors" then
Achievement({
Title = "GlitchRush",
Desc = "GlitchRush Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://11102256553",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("GlitchRush Â∑≤ÁîüÊàê", 3)
Sound()
end
end
if v.Name == "GlitchAmbush" and Options.EntitiesPicker.Value["GlitchAmbush"] then
if OptionNotify == "Doors" then
Achievement({
Title = "GlitchAmbush",
Desc = "GlitchAmbush Â∑≤ÁîüÊàê",
Reason = "Âø´ÂéªÂØªÊâæË∫≤ËóèÁÇπ",
Image = "rbxassetid://10938726652",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("GlitchAmbush Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "Groundskeeper" and Options.EntitiesPicker.Value["Groundskeeper"] then
Notify("Groudskeeper Â∑≤ÁîüÊàê",3)
Sound()
end

if v.Name == "MonumentEntity" and Options.EntitiesPicker.Value["Monument"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Monument",
Desc = "Monument Â∑≤ÁîüÊàê",
Reason = "ÁúãÁùÄÂÆÉ",
Image = "",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("Monument Â∑≤ÁîüÊàê", 3)
Sound()
end
end

if v.Name == "SeekMovingNewClone" and Options.EntitiesPicker.Value["Seek"] then
if OptionNotify == "Doors" then
Achievement({
Title = "SeekÂèëÂ∞ÑÂô®",
Desc = "SeekÂèëÂ∞ÑÂô® Â∑≤ÁîüÊàê",
Reason = "‰∏ã‰∏ÄÈó®ÊúâSeek",
Image = "rbxassetid://109124151043322",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Library:Notify("SeekÂèëÂ∞ÑÂô® Â∑≤ÁîüÊàê", 3)
Sound()
end
end

end
if Toggles.EntitesESP.Value then
if v.Name == "RushMoving" then
addESP(v,"Rush")
end



if v.Name == "AmbushMoving" then
addESP(v,"Ambush")
end

if v.Name == "A60" then
addESP(v,"A-60")
end

if v.Name == "A120" then
addESP(v,"A-120")
end

if v.Name == "Eyes" then
addESP(v,"Eyes")
end

if v.Name == "BackdoorLookman" then
addESP(v,"Lookman")
end
if v.Name == "BackdoorRush" then
addESP(v,"Blitz")
end

if v.Name == "Groundskeeper" then
addESP(v, "Groundskeeper")
end

if v.Name == "MonumentEntity" then
addESP(v:WaitForChild("Top"),"Monument")
end

end

end)
)

Toggles.TransparencyCloset:OnChanged(function(Value)

if not Value then

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do


if v:FindFirstChild("HidePrompt") then

for _, base in ipairs(v:GetChildren()) do


if base:IsA("BasePart") and not (base.Name == "PlayerCollision" or base.Name == "Collision") then


base.Transparency = 0 

end

end

end

end
end


end)

table.insert(Connections,Character:GetAttributeChangedSignal("Hiding"):Connect(function()
 Closet = nil
if Character:GetAttribute("Hiding") == true then
for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetDescendants()) do
if v:FindFirstChild("HidePrompt") then
if v:FindFirstChild("HiddenPlayer") and v.HiddenPlayer.Value ~= nil then
Closet = v


end
end
end


else
for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetDescendants()) do
if v:FindFirstChild("HidePrompt") then


for _, base in ipairs(v:GetChildren()) do
if base:IsA("BasePart") and not
(base.Name == "PlayerCollision" or base.Name == "Collision")  then
base.Transparency = 0

end

end


end
end
end

end)
)


print("RenderStepped")


table.insert(Connections,RunService.Heartbeat:Connect(function()
if alive then
if Toggles.AutoRooms and Toggles.AutoRooms.Value then

if ReplicatedStorage.GameData.LatestRoom.Value == 1000 then return end

if Toggles.AutoCloset.Value then
Toggles.AutoCloset:SetValue(false)
Library:Notify("Á¶ÅÁî®Ëá™Âä®Ë∫≤ËóèÔºå‰ΩøËá™Âä®ÊàøÈó¥Ê≠£Â∏∏ËøêË°å",4)

end
local entity2 = Workspace:FindFirstChild("A60") or Workspace:FindFirstChild("A120") or Workspace:FindFirstChild("GlitchRush") or Workspace:FindFirstChild("GlitchAmbush")

if entity2 and entity2.PrimaryPart and entity2.PrimaryPart.Position.Y > -6  then
local Locker = GetNearestLocker()

if Locker then

if not Locker:FindFirstChild("Hide") then
local Part = Instance.new("Part",Locker)
Part.Position = Locker.PrimaryPart.Position + Locker.PrimaryPart.CFrame.LookVector * 7
Part.Size = Vector3.new(1, 1, 1)
Part.CanCollide = false
Part.Transparency = 1
Part.Anchored = true
Part.Name = "Hide"
end

moveto(Locker:WaitForChild("Hide"))
if not LocalPlayer.Character.CollisionPart.Anchored then

fireproximityprompt(Locker:WaitForChild("HidePrompt"))
end

end

elseif not entity or entity.PrimaryPart.Position.Y < -9 then
LocalPlayer.Character:SetAttribute("Hiding",false)

moveto(workspace.CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value].Door.Door)

end

end

end 

end))

table.insert(Connections,RunService.RenderStepped:Connect(function()
alive = LocalPlayer:GetAttribute("Alive")
if alive then

if Toggles.Fullbright.Value then
Lighting.Ambient = Color3.fromRGB(255, 255, 255)

end


if Options.GMDropdown and Options.GMDropdown.Value == "Ëá™Âä®" then

local Entitys = workspace:FindFirstChild("RushMoving") or workspace:FindFirstChild("AmbushMoving") or workspace:FindFirstChild("GlitchRush") or workspace:FindFirstChild("GlitchAmbush") or workspace:FindFirstChild("BackdoorRush")

if Entitys and not Toggles.GodMode.Value then
Toggles.GodMode:SetValue(true)
elseif not Entitys and Toggles.GodMode.Value then
Toggles.GodMode:SetValue(false)
end

end

if Toggles.TransparencyCloset.Value then

if Closet then
  
for _, v in ipairs(Closet:GetChildren()) do

if v:IsA("BasePart") and  not (v.Name == "PlayerCollision" or v.Name == "Collision") then

v.Transparency = TransparencyValue

end

end

end

end

if ESPLibrary and ESPLibrary.GlobalConfig then
for model, espObject in pairs(ESPObjects) do
if model and model.Parent and espObject and espObject.CurrentSettings then
if espObject.CurrentSettings.Tracer then
espObject.CurrentSettings.Tracer.Thickness = ESPConfig.Tracer.Thickness
end
if espObject.GUI and espObject.GUI.Tracer then
espObject:Hide()
espObject:Show()
end
end
end
end

if Toggles.AutoEatCandies.Value then
local candyInBackpack = LocalPlayer.Backpack:FindFirstChild("Candy")
if candyInBackpack and candyInBackpack:FindFirstChild("Remote") then
candyInBackpack.Parent = LocalPlayer.Character
end
local candyInCharacter = LocalPlayer.Character:FindFirstChild("Candy")
if candyInCharacter and candyInCharacter:FindFirstChild("Remote") then
local isDeathCandy = candyInCharacter:GetAttribute("Tool_CandyID") == "CandyRed"
if not isDeathCandy then
candyInCharacter.Remote:FireServer()
else
end
end
end

if Toggles.Spamtoolz and Toggles.Spamtoolz.Value and Options.Spamtoolz_X and Options.Spamtoolz_X:GetState() then
task.wait()
for _, Player in pairs(game.Players:GetPlayers()) do
if Player ~= LocalPlayer and Player then
if Player.Backpack then
for _, v in pairs(Player.Backpack:GetChildren()) do
if v.Name ~= "Candle" and v:FindFirstChildWhichIsA("RemoteEvent") then
v:FindFirstChildWhichIsA("RemoteEvent"):FireServer()
end
end
end
if Player.Character then
local Tool = Player.Character:FindFirstChildWhichIsA("Tool")
if Tool and Tool.Name ~= "Candle" and Tool:FindFirstChild("Remote") then
Tool.Remote:FireServer()
end
end
end
end
end

if Toggles.SpeedBoost.Value then

Character.Humanoid.WalkSpeed = Speed
end

if Toggles.SpeedBoost.Value then
    Character.Humanoid.WalkSpeed = Speed
    
if Floor.Value == "Mines" and LocalPlayer.Character:GetAttribute("Climbing") then
Character.Humanoid.WalkSpeed = Speed + Options.LadderSpeedBoost.Value
end
end

if Toggles.AutoCloset.Value then
local Closet = GetNearestCloset()
for _, v in ipairs(workspace:GetChildren()) do
local range = EntitysTable[v.Name]
if range and v.PrimaryPart then

if (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude <= range then 
if Closet then
if not LocalPlayer.Character.PrimaryPart.Anchored then
fireInteract(Closet:WaitForChild("HidePrompt"))
end
end
elseif (LocalPlayer.Character.HumanoidRootPart.Position - v.PrimaryPart.Position).Magnitude > range then 
LocalPlayer.Character:SetAttribute("Hiding",false)

if not v:GetAttribute("Destroying") then
v:SetAttribute("Destroying",true)
v.Destroying:Connect(function()
LocalPlayer.Character:SetAttribute("Hiding",false)
end)
end
end
end
end
end

if Toggles.Door and Toggles.Door.Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
local roomNumber = tonumber(room.Name)
if roomNumber and shouldShowESP(roomNumber) then
if room:FindFirstChild("Door") and room.Door:FindFirstChild("Door") then
local Door = room.Door.Door
if not Door:GetAttribute("Used") then
local espObject = ESPObjects[Door]
if espObject then
local displayText = "Èó® " .. Door.Parent:GetAttribute("RoomID")
local currentRoom = LocalPlayer:GetAttribute("CurrentRoom")
local isLocked = false
local isOpen = not Door.Anchored

if roomNumber == currentRoom then
if Door.Parent:FindFirstChild("Lock") then
isLocked = true
end
elseif roomNumber == currentRoom + 1 then
local keyFound = false
for _, obj in ipairs(room:GetDescendants()) do
if obj.Name == "KeyObtain" and not obj:GetAttribute("Used") then
keyFound = true
break
end
end
if keyFound then
isLocked = true
end
end

if isOpen then
displayText = "[Â∑≤ÊâìÂºÄ] " .. displayText
else
if isLocked then
displayText = "[ÈîÅÂÆö] " .. displayText
end
end

espObject.CurrentSettings.Name = displayText

if espObject.GUI and espObject.GUI.Txt then
espObject.GUI.Txt.Text = displayText
end
end
end
end
end
end
end

if Toggles.NoClosetExitDelay.Value then
if LocalPlayer.Character:GetAttribute("Hiding") == true then
if (Character.Humanoid.MoveDirection.Magnitude > 0.5)  then
RemoteFolder.CamLock:FireServer()
end
end
end 


if Toggles.NoCutscenes.Value then
if (ReplicatedStorage.GameData.LatestRoom.Value > 89) then

Toggles.NoCutscenes:SetValue(false)
end
end

if Toggles.InfiniteItems and Toggles.InfiniteItems.Value then
local hasTool = Character:FindFirstChild("Lockpick") or Character:FindFirstChild("SkeletonKey")
				if hasTool then

					for _, prompt in ipairs(InfStore) do
						if prompt and prompt.Parent and not prompt:GetAttribute("HasFake") == true then
							addFake(prompt, "Lockpick")
						end
					end

				end
			end
if Toggles.InfiniteSItems and Toggles.InfiniteSItems.Value then
local hasTool =  LocalPlayer.Character:FindFirstChild("Shears")
				if hasTool then

					for _, prompt in ipairs(InfSStore) do
						if prompt and prompt.Parent and not prompt:GetAttribute("HasFake") == true then
							addFake(prompt, "Shears")
						end
					end

				end
			end

if Toggles.Noacceleration.Value then
Character.HumanoidRootPart.CustomPhysicalProperties = PhysicalProperties.new(100,0.5,0.2)
Character.Collision.CustomPhysicalProperties = PhysicalProperties.new(100,0.5,0.2)
else
Character.HumanoidRootPart.CustomPhysicalProperties =  PhysicalProperties.new(0.4,0.2,0.2)
Character.Collision.CustomPhysicalProperties = PhysicalProperties.new(0.4,0.2,0.2)
end

if Toggles.AntiHear.Value and ReplicatedStorage:FindFirstChild("RemotesFolder") then
RemoteFolder.Crouch:FireServer(true)
end

if Toggles.Noclip.Value then
if alive then
LocalPlayer.Character.Collision.CanCollide = false
if LocalPlayer.Character.Collision:FindFirstChild("CollisionCrouch") then
LocalPlayer.Character.Collision.CollisionCrouch.CanCollide = false

end
if LocalPlayer.Character:FindFirstChild("CollisionPart")  then
LocalPlayer.Character:FindFirstChild("CollisionPart").CanCollide = false
end

LocalPlayer.Character.HumanoidRootPart.CanCollide = false
end
end
if Toggles.NoCameraShake.Value then
if alive then
RequiredMainGame.csgo = CFrame.new()
end
end
if  Toggles.DeleteFigure and Toggles.DeleteFigure.Value then
if alive then
local Figure = workspace.CurrentRooms:FindFirstChild("FigureRig",true)
if Figure and Figure:FindFirstChild("Root") and isnetworkowner(Figure.Root) then
if Figure:FindFirstChild("Root") then
Figure.Root.Size = Vector3.new(0.4, 2000, 0.4)
Figure.Root.CanCollide = false
Figure.Hitbox.CanCollide = false
end
end
end
end

if  Toggles.DeleteFigureFools and Toggles.DeleteFigureFools.Value then
if alive then
local Figure = workspace:FindFirstChild("FigureRagdoll",true)
if Figure and Figure:FindFirstChild("Root") and isnetworkowner(Figure.Root) then
if Figure:FindFirstChild("Root") then
Figure:PivotTo(Figure.Root.CFrame * CFrame.new(30, 900, 300))
Figure.Root.CanCollide = false
end
end
end
end


if Toggles.DoorReach.Value then
if alive then
local Door = workspace.CurrentRooms[ReplicatedStorage.GameData.LatestRoom.Value].Door
if Door and Door:FindFirstChild("ClientOpen") then
if (Character.HumanoidRootPart.Position - Door.Door.Position).Magnitude < Range then
Door.ClientOpen:FireServer()
end
end
end
end

if Toggles.AntiEyes.Value then
if alive then
if Workspace:FindFirstChild("Eyes") then
if RemoteFolder.Name == "Bricks" or RemoteFolder.Name == "EntityInfo" then
RemoteFolder.MotorReplication:FireServer(0, -100, 0, false)
else
RemoteFolder.MotorReplication:FireServer(-890)
end

end
end
end

if Toggles.SpectateEntity.Value then
if alive then
for _, entity in ipairs(workspace:GetChildren()) do
if SpectateTable[entity.Name] then
if entity.PrimaryPart then 
if Character:GetAttribute("Hiding") == true then
Workspace.Camera.CFrame = CFrame.lookAt(Workspace.CurrentCamera.CFrame.Position, entity.PrimaryPart.Position)
           end
      end
end
end
end
end

if Toggles.AntiLookman.Value then
if alive then
if Workspace:FindFirstChild("BackdoorLookman") then
RemoteFolder.MotorReplication:FireServer(-890)

end
end
end

if Toggles.TransparencyCart.Value then
if Workspace.CurrentCamera and Workspace.CurrentCamera:FindFirstChild("MinecartRig") then
for _, v in ipairs(workspace.CurrentCamera.MinecartRig:GetChildren()) do
if v:IsA("BasePart") then
v.Transparency = CartTransparencyValue


end
end

end
end
if Toggles.FigureGodmode then

local Figure = workspace:FindFirstChild("FigureRagdoll", true)
if Figure then
for _, v in Figure:GetChildren() do
if v:IsA("BasePart") then
v.CanTouch = not Toggles.FigureGodmode.Value
end
end

end

end

if Toggles.AutoInteract.Value then
    for _, prompt in ipairs(AutoInteractTable) do
        if prompt and prompt.Parent then
            local check = prompt:GetAttribute("Interactions")
            local isMinesGateButton = prompt.Parent and prompt.Parent.Name == "Button" and 
                                     prompt.Parent.Parent and prompt.Parent.Parent.Name == "MinesGateButton"
            local isFusesPrompt = prompt.Name == "FusesPrompt"
            local isMinesAnchorPrompt = prompt.Parent and prompt.Parent.Name == "MinesAnchor" and prompt.Name == "ActivateEventPrompt"
            
            if isMinesGateButton or isFusesPrompt or (not check or check < 1) then
                if isMinesAnchorPrompt then
                    return
                end
                
                local Base
                if prompt.Parent:IsA("BasePart") then
                    Base = prompt.Parent
                elseif prompt.Parent.Parent and prompt.Parent.Parent:IsA("BasePart") then
                    Base = prompt.Parent.Parent
                elseif prompt.Parent and prompt.Parent:FindFirstChildWhichIsA("BasePart") then
                    Base = prompt.Parent:FindFirstChildWhichIsA("BasePart")
                else
                    if prompt.Parent.Parent and prompt.Parent.Parent:FindFirstChildOfClass("BasePart") then
                        Base = prompt.Parent.Parent:FindFirstChildOfClass("BasePart")
                    end
                end
                
                if Base and (LocalPlayer.Character.HumanoidRootPart.Position - Base.Position).Magnitude < prompt.MaxActivationDistance then
                    if not (isMinesGateButton or isFusesPrompt) then
                        local isTrickOrTreat = false
                        if prompt.Name == "ActivateEventPrompt" then
                            local parent = prompt.Parent
                            if parent and parent.Name == "HouseDoor" then
                                local grandParent = parent.Parent
                                if grandParent and (grandParent.Name == "TrickOrTreatHouse" or grandParent.Name == "TrickOrTreatDoor") then
                                    isTrickOrTreat = true
                                end
                            end
                        end
                        if isTrickOrTreat then
                            return
                        end
                        
                        if prompt.Parent and prompt.Parent.Name == "GlitchCube" and Options.IgnoreList.Value["ÊïÖÈöúÊñπÂùó"] then
                            return
                        end
                        if prompt.Parent and prompt.Parent.Name == "GoldPile" and Options.IgnoreList.Value["ÈáëÂ∏Å"] then return end
                        if prompt.Name == "ModulePrompt" and prompt.Parent and prompt.Parent.Name == "Candy" and Options.IgnoreList.Value["Á≥ñÊûú"] then
                            return
                        end
                        if prompt.Parent:GetAttribute("JeffShop") and Options.IgnoreList.Value["JeffÁâ©ÂìÅ"] then return end
                        if prompt.Parent.Parent and prompt.Parent.Parent.Name == "Drops" and Options.IgnoreList.Value["‰∏¢ÂºÉÁâ©ÂìÅ"] then return end
                        if prompt.Parent and prompt.Parent.Name == "Candy" and prompt.Parent:GetAttribute("Tool_CandyID") == "CandyRed" and Options.IgnoreList.Value["Ê≠ª‰∫°Á≥ñÊûú"] then
                            return
                        end
                        if prompt.Parent and prompt.Parent.Parent and prompt.Parent.Parent.Name == "WGrampyShop" and Options.IgnoreList.Value["GrampyÁâ©ÂìÅ"] then
                            return
                        end
                        if prompt.Name == "ModulePrompt" and prompt.Parent and prompt.Parent.Name == "Hole" then return end
                        if prompt.Name == "ModulePrompt" and prompt.Parent and prompt.Parent.Name == "Mandrake" then return end
                        if prompt.Parent and prompt.Parent.Name == "Padlock" then return end
                        if prompt.Parent and prompt.Parent.Name == "KeyObtainFake" then return end
                        if isMinesAnchorPrompt then
                            return
                        end
                    end

                    if prompt.ClickablePrompt then
                        fireInteract(prompt)
                    end
                end
            end
        end
    end
end


if CollisionClone and CollisionClone.Anchored then
CollisionClone.Anchored = false
end
if CollisionClone2 and CollisionClone2.Anchored then
CollisionClone2.Anchored = false
end

end



end))


table.insert(Connections,LocalPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
    if Toggles.Door and Toggles.Door.Value then
        for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
            if room:FindFirstChild("Door") and room.Door:FindFirstChild("Door") then
                ESPLibrary:RemoveESP(room.Door.Door)
            end
        end
        
        local currentRoom = LocalPlayer:GetAttribute("CurrentRoom")
        if currentRoom then
            for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
                local roomNumber = tonumber(room.Name)
                if roomNumber and (roomNumber == currentRoom or roomNumber == currentRoom + 1) then
                    if room:FindFirstChild("Door") and room.Door:FindFirstChild("Door") then
                        local Door = room.Door.Door
                        if not Door:GetAttribute("Used") then
                            local displayText = "Èó® " .. Door.Parent:GetAttribute("RoomID")
                            
                            if roomNumber == currentRoom then
                                if Door.Parent:FindFirstChild("Lock") then
                                    displayText = "[ÈîÅÂÆö] " .. displayText
                                end
                            elseif roomNumber == currentRoom + 1 then
                                local keyFound = false
                                for _, obj in ipairs(room:GetDescendants()) do
                                    if obj.Name == "KeyObtain" and not obj:GetAttribute("Used") then
                                        keyFound = true
                                        break
                                    end
                                end
                                if keyFound then
                                    displayText = "[ÈîÅÂÆö] " .. displayText
                                end
                            end
                            
                            AddESP(Door, displayText, DoorColor)
                        end
                    end
                end
            end
        end
    end
    if Toggles.Stardust and Toggles.Stardust.Value then
    Toggles.Stardust:SetValue(false)
    Toggles.Stardust:SetValue(true)
    end
    if Toggles.Chest and Toggles.Chest.Value then
    Toggles.Chest:SetValue(false)
    Toggles.Chest:SetValue(true)
    end
    if Toggles.HidingSpot and Toggles.HidingSpot.Value then
        Toggles.HidingSpot:SetValue(false)
        Toggles.HidingSpot:SetValue(true)
    end
    if Toggles.TaskESP and Toggles.TaskESP.Value then
    Toggles.TaskESP:SetValue(false)
    Toggles.TaskESP:SetValue(true)
    end
    if Toggles.Gold and Toggles.Gold.Value then
        Toggles.Gold:SetValue(false)
        Toggles.Gold:SetValue(true)
    end

if Toggles.AntiSnare.Value then
for _, room in ipairs(workspace.CurrentRooms:GetChildren()) do
if room:FindFirstChild("Snares") then
for _, v in ipairs(room.Snares:GetChildren()) do
if v.Name == "Snare" then
v:WaitForChild("Hitbox",9e9).CanTouch = false
end
end
end
        
if room:FindFirstChild("Assets") then
for _, v in ipairs(room.Assets:GetChildren()) do
if v.Name == "Snare" then
v:WaitForChild("Hitbox",9e9).CanTouch = false
end
end
end
end
end
if Toggles.AntiDupe.Value then
for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetChildren()) do



if v and v.Name == "SideroomDupe" then

v:WaitForChild("DoorFake",9e9):WaitForChild("Hidden",9e9).CanTouch = false

end

end

end

for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetChildren()) do




if v.Name == "SideroomDupe" then


if v:WaitForChild("DoorFake"):FindFirstChild("Lock") then
v:WaitForChild("DoorFake"):FindFirstChild("Lock"):FindFirstChildOfClass("ProximityPrompt").Enabled =  not Toggles.AntiDupe.Value 


end


end

end

if Toggles.AntiGiggle and Toggles.AntiGiggle.Value then
for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:GetChildren()) do
if v.Name == "GiggleCeiling" then
v:WaitForChild("Hitbox",9e9).CanTouch = false
end
end
end


if Toggles.AntiVacuum.Value then
for _, v in ipairs(workspace.CurrentRooms:GetChildren()) do
if v.Name == "SideroomSpace" then
v:WaitForChild("Collision").CanTouch = false
v:WaitForChild("Collision").CanCollide = true
end
end
end


if Toggles.Door.Value then
local room = LocalPlayer:GetAttribute("CurrentRoom")

local lastroom = room - 1
local Door = workspace.CurrentRooms[lastroom].Door.Door
if Door then
ESPLibrary:RemoveESP(Door)
end

local Door = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")].Door.Door
if not Door:GetAttribute("Used") then
local displayText = "Èó® " .. Door.Parent:GetAttribute("RoomID")
local isLocked = Door.Parent:FindFirstChild("Lock") ~= nil
local isOpen = not Door.Anchored

if isOpen then
displayText = "[Â∑≤ÊâìÂºÄ] " .. displayText
elseif isLocked then
displayText = "[ÈîÅÂÆö] " .. displayText
end

AddESP(Door, displayText, DoorColor)
end
end

if Toggles.EntityNotifys.Value then
local v = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:FindFirstChild("Groundskeeper",true)
if v and Options.EntitiesPicker.Value["Groundskeeper"] then
if OptionNotify == "Doors" then
Achievement({
Title = "Groundskeeper",
Desc = "Groundskeeper Â∑≤ÁîüÊàê",
Reason = "‰∏çË¶ÅË∏©Ë∏èËçâÂù™",
Image = "",
Text = "WARNING",
TextColor = Color3.fromRGB(255, 0, 0),
UIStrokeColor = Color3.fromRGB(255, 0, 0)
})
else
Notify("Groundskeeper Â∑≤ÁîüÊàê", 3)
Sound()
end
end
end

if Toggles.EntitesESP.Value then
local Groundskeeper = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:FindFirstChild("Groundskeeper", true)
if Groundskeeper then
addESP(Groundskeeper, "Groundskeeper")
end
end

if Toggles.Ladder and Toggles.Ladder.Value then
local v = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:FindFirstChild("Ladder",true)

if v then
AddESP(v,"Ê¢ØÂ≠ê",Color3.new(0,0,1))
end



end


if Toggles.TaskESP.Value then

local v = workspace.CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value]:FindFirstChild("KeyObtain",true)
if v and not v:GetAttribute("Used") then
AddESP(v,"Èí•Âåô",TaskColor)

end
end
if Toggles.TaskESP.Value then
local Lever = workspace.CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value]:FindFirstChild("Assets"):FindFirstChild("LeverForGate")
if Lever then 
AddESP(Lever,"Èó®ÊãâÊùÜ ",TaskColor)

end
end
if Toggles.EntitesESP.Value then
local Figure = workspace.CurrentRooms:FindFirstChild("FigureRig",true) or workspace.CurrentRooms:FindFirstChild("FigureRagdoll",true)

if Figure then
addESP(Figure,"Figure")

end
end
if Toggles.EntitesESP.Value then
local Entity = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:FindFirstChild("LiveEntityBramble",true)
if Entity then
addESP(Entity,"Bramble")


end
end
if Toggles.TaskESP and Toggles.TaskESP.Value then
local v = workspace.CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value]:FindFirstChild("GeneratorMain",true)
if v then 
AddESP(v,"ÂèëÁîµÊú∫",TaskColor)

end
end
if Toggles.TaskESP.Value then
local v = workspace.CurrentRooms[game.ReplicatedStorage.GameData.LatestRoom.Value]:FindFirstChild("TimerLever",true)
if v then

AddESP(v,"ÂÄíËÆ°Êó∂ÊãâÊùÜ",TaskColor)
end
end
if Toggles.HidingSpot.Value then
if ReplicatedStorage:FindFirstChild("RemotesFolder") then
local room = LocalPlayer:GetAttribute("CurrentRoom")
if room and room > 0 then
local lastroom = room - 1
for _, v in ipairs(workspace.CurrentRooms[lastroom]:GetDescendants()) do
local TextName = HidingSpots[v.Name]
if TextName and v.PrimaryPart then
ESPLibrary:RemoveESP(v)

end
end
end

end




for _, v in ipairs(workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]:FindFirstChild("Assets",true):GetChildren()) do
local TextName = HidingSpots[v.Name]
if TextName and v.PrimaryPart then
AddESP(v,TextName,HidingSpotColor)

end
end

end


end)
)
Toggles.NoCutscenes:OnChanged(function(Value)
local CutScenes = RemoteListener:FindFirstChild("Cutscenes") or RemoteListener:FindFirstChild("_Cutscenes")
CutScenes.Name = Value and "_Cutscenes" or "Cutscenes"
end)

Toggles.EnableJump:OnChanged(function(Value)
if Character then
Character:SetAttribute("CanJump",Value)
end

end)
print("hi0")

 

local InfiniteTable = {
    Chest_Vine = true, CuttableVines = true, Cellar = true,
UnlockPrompt = true, ThingToEnable = true, LockPrompt = true, SkullPrompt = true, FusesPrompt = true,
ChestBoxLocked = true, Locker_Small_Locked = true, Toolbox_Locked = true
}

local ImportantNames = {
    LiveObstructionNew = true,
LiveObstructionNewIntro = true,
    ChandelierObstruction = true,
    Seek_Arm = true,
    
    Egg = true,
    
    LiveHintBook = true,
    LiveBreakerPolePickup = true,
    Lever = true,
    MinesAnchor = true,
    VineGuillotine = true,
 GoldPile = true,
FuseObtain = true,
    Toolbox = true,
    CuttableVines = true, Cellar = true,
UnlockPrompt = true, ThingToEnable = true, LockPrompt = true, SkullPrompt = true, FusesPrompt = true,
Locker_Small_Locked = true, Toolbox_Locked = true,
    Flashlight = true,
    Lockpick = true,
    Vitamins = true,
    Bandage = true,
    StarVial = true,
    StarBottle = true,
    StarJug = true,
    Shakelight = true,
    Straplight = true,
    Bulklight = true,
    Battery = true,
    Candle = true,
    Crucifix = true,
    CrucifixWall = true,
    Glowsticks = true,
    SkeletonKey = true,
    Candy = true,
    ShieldMini = true,
    ShieldBig = true,
    BandagePack = true,
    BatteryPack = true,
    RiftCandle = true,
    LaserPointer = true,
    HolyGrenade = true,
    Shears = true,
    Smoothie = true,
    Cheese = true,
    Bread = true,
    AlarmClock = true,
    RiftSmoothie = true,
    GweenSoda = true,
    GlitchCub = true,
    RiftJar = true,
    Compass = true,
    Lantern = true,
    Multitool = true,
    Lotus = true,
    TipJar = true,
    LotusPetalPickup = true,
    KeyIron = true,
    CandyBag = true,
    Donut = true,
    Toolshed_Small = true,
    Chest_Vine = true,
    ChestBoxLocked = true,
    ChestBox = true,
    StardustPickup = true,
ElevatorBreaker = true,
WaterPump = true,
GrumbleRig = true,
PowerupPad = true,
SeekGuidingLight = true,
DoorNormal = true,
DoorFrame = true,
Luggage_Cart_Crouch = true,
Carpet = true,
Floor = true,
CarpetLight = true,
Luggage_Cart = true,
DropCeiling = true,
End_DoorFrame = true,
SeeThroughGlass = true,
Start_DoorFrame = true,
TriggerEventCollision = true,
DoorLattice = true,
Collision = true
}

 table.insert(Connections,
workspace.DescendantAdded:Connect(function(v)
    local Delay = math.random(200, 270) / 1000
    task.wait(Delay)

    if v:IsA("ProximityPrompt") then
        local isMinesGateButton = v.Parent and v.Parent.Name == "Button" and 
                                 v.Parent.Parent and v.Parent.Parent.Name == "MinesGateButton"
        
        local isFusesPrompt = v.Name == "FusesPrompt"
        
        local isMinesAnchorPrompt = v.Parent and v.Parent.Name == "MinesAnchor" and v.Name == "ActivateEventPrompt"
        
        if Toggles.AutoInteract.Value then
            if v and (not Ignore[v.Name] or isMinesGateButton or isFusesPrompt) then
                if not isMinesAnchorPrompt then
                    if v:IsA("ProximityPrompt") then
                        table.insert(AutoInteractTable, v)
                    end
                end
            end
        end


if Toggles.PromptReach.Value then
v:SetAttribute("Distance",v.MaxActivationDistance)
v.MaxActivationDistance = v.MaxActivationDistance * promptReachMultiplier
end

if Toggles.PromptClip.Value then


v.RequiresLineOfSight = false 

end

if Toggles.InstantPrompt.Value then


v:SetAttribute("Hold",v.HoldDuration)

v.HoldDuration =  0

end


end
if Toggles.AntiLag.Value then
if v:IsA("BasePart") then
v.Material = Enum.Material.Plastic
end
if v.Name == "LightFixture" or v.Name == "Carpet" or v.Name == "CarpetLight" then
v:Destroy()
end
if v:IsA("Texture") then
v:Destroy()
end








end

if not ImportantNames[v.Name] then return end


if Toggles.AutoDoors and Toggles.AutoDoors.Value then

if  Objects[v.Name] then 
canhit(v)
end
if v.Name == "LiveObstructionNew" or v.Name == "LiveObstructionNewIntro"  then
canhit(v:WaitForChild("Collision"))
end
if not v:IsA("Part") and v.Name == "SeeThroughGlass" then

canhit(
v
)

end
if v.Name == "Collision" and v.Parent and v.Parent.Name == "Parts" then
v.CanCollide = false 

end
if v.Name == "DoorLattice" then
canhit(v:WaitForChild("Door",9e9))
end




end








if Toggles.AutoBreakerBox.Value then
if v.Name == "ElevatorBreaker" then 
Breaker = v
end
end
if Toggles.TaskESP and Toggles.TaskESP.Value then

if v.Name == "WaterPump" then
AddESP(v,"Ê∞¥Ê≥µ",TaskColor)
end

end








if Toggles.InfiniteSItems and Toggles.InfiniteSItems.Value then

if ShearsParents[v.Name] or ShearsNames[v.Name] then
if v:IsA("ProximityPrompt") then
table.insert(InfSStore,v)
else
table.insert(InfSStore,v:FindFirstChildOfClass("ProximityPrompt"))
end
end
end

if Toggles.InfiniteItems and Toggles.InfiniteItems.Value then

if LockpickNames[v.Name] or LockpickParents[v.Name] then
if v:IsA("ProximityPrompt") then
table.insert(InfStore,v)
else
table.insert(InfStore,v:FindFirstChildOfClass("ProximityPrompt"))
end
end
end

if Toggles.AntiSeekObstructions.Value then
if v.Name == "ChandelierObstruction" or v.Name == "Seek_Arm" then
for _, part in ipairs(v:GetChildren()) do
if part:IsA("BasePart") then part.CanTouch = false
end
end
end

end



if Toggles.TaskESP.Value then
if v.Name == "LiveHintBook" then
AddESP(v,"‰π¶",TaskColor)
end
end

if Toggles.TaskESP.Value then
if v.Name == "LiveBreakerPolePickup" then
AddESP(v,"Êñ≠Ë∑ØÂô®",TaskColor)
end
end







if Toggles.AntiGloomPile and Toggles.AntiGloomPile.Value then
if v.Name == "Egg" then v.CanTouch = false


end


end





if Toggles.TaskESP and Toggles.TaskESP.Value then
if v.Name == "MinesAnchor" then
AddESP(v,"Èîö " ..  v:WaitForChild("Sign").TextLabel.Text,TaskColor)
end
end

if Toggles.Items.Value then
local name = Item[v.Name]
if name then
AddESP(v,name,ItemsColor)

end


end
if Toggles.TaskESP and Toggles.TaskESP.Value then



if v.Name == "FuseObtain" then


AddESP(v,"‰øùÈô©‰∏ù",TaskColor)
end
end


if v.Name == "GrumbleRig" then
addESP(v,"Grumble")
end



if Toggles.Gold.Value then
if v.Name == "GoldPile" then
AddESP(v,"ÈáëÂ∏Å " .. v:GetAttribute("GoldValue"),GoldColor)
end

end

if (Floor.Value == "Garden") and Toggles.TaskESP.Value then

if v and v.Parent and v.Parent.Name == "VineGuillotine" and v.Name == "Lever" then

AddESP(v,"ÊãâÊùÜ",TaskColor)


end


end
if Toggles.AutoGetPowerUps and Toggles.AutoGetPowerUps.Value and  v.Name == "PowerupPad" then
v:WaitForChild("Hitbox",9e9).Size = Vector3.new(90, 90, 90)

end

end))

local old
print("Hi1")



if  not Disable5 then

old = hookmetamethod(game,"__namecall",newcclosure(function(self, ...)
local args = { ... }
local method = getnamecallmethod()

if self.Name == "ClutchHeartbeat" and method == "FireServer" and Toggles.AutoHeartbeatMiniGame.Value then
args[1] = true
return old(self,unpack(args()))

end

return old(self, ...)



end))
end






print("hi2")





function Unload()
if hidingTimeConnection then
hidingTimeConnection:Disconnect()
hidingTimeConnection = nil
end
if hideMonsterHook then
hideMonsterHook:Disconnect()
hideMonsterHook = nil
end
if hidingAttributeConnection then
hidingAttributeConnection:Disconnect()
hidingAttributeConnection = nil
end
if hidingNotification then
hidingNotification:Destroy()
hidingNotification = nil
end
hidingStartTime = nil
currentHideDuration = nil
if noVignetteLoop then
noVignetteLoop:Disconnect()
noVignetteLoop = nil
end
if noOxygenVignetteLoop then
noOxygenVignetteLoop:Disconnect()
noOxygenVignetteLoop = nil
end
if WatermarkConnection then
WatermarkConnection:Disconnect()
WatermarkConnection = nil
end
if minecartConnection then
minecartConnection:Disconnect()
minecartConnection = nil
end
if ESPLibrary and ESPLibrary.GlobalConfig then
ESPLibrary.GlobalConfig.Rainbow = false
end
if AutoDoorsConnection then
AutoDoorsConnection:Disconnect()
AutoDoorsConnection = nil
end
LocalPlayer.Character.Head.PointLight.Brightness = 1
LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position)

if workspace:FindFirstChild("Path Node") then

workspace:FindFirstChild("Path Node"):Destroy()



end

LocalPlayer:SetAttribute("StarringLoaded",false)
Library.Unloaded = true
for i, Toggle in ipairs(Toggles) do
Toggle:SetValue(false)
end
for _, connection in pairs(jumpPowerConnections) do
if connection then
connection:Disconnect()
end
end
    jumpPowerConnections = {}
for _, Connection in ipairs(Connections) do
Connection:Disconnect()
end

Library:Unload()
ESPLibrary:Unload()

GodModeCameraHandler.enabled = false
pcall(function() RunService:UnbindFromRenderStep("GOD_MODE_CAMERA_SYS") end)

if Character.HumanoidRootPart:FindFirstChild("FlyBodyVelocity") then

Character.HumanoidRootPart:FindFirstChild("FlyBodyVelocity"):Destroy()
end
if Character.HumanoidRootPart:FindFirstChild("FlyBodyGyro") then
Character.HumanoidRootPart:FindFirstChild("FlyBodyGyro"):Destroy()
end
if RemoteFolder:FindFirstChild("Crouch") then


RemoteFolder.Crouch:FireServer(false)

end

Character.Humanoid.PlatformStand = false 
Character:SetAttribute("CanJump",false)
if FakeSurge then
FakeSurge:Destroy()
end
if ReplicatedStorage:FindFirstChild("SurgeRemote") then
ReplicatedStorage.SurgeRemote.Parent = ReplicatedStorage.RemotesFolder
end
if VoidModule and VoidModule.originalStuff then
VoidModule.stuff = VoidModule.originalStuff
VoidModule.originalStuff = nil
end
local SpiderModule = ClientModules.EntityModules:FindFirstChild("_SpiderJumpscare")
if SpiderModule then
SpiderModule.Name = "SpiderJumpscare"
end
local GlitchModule = ClientModules.EntityModules:FindFirstChild("_Glitch")
if GlitchModule then
GlitchModule.Name = "Glitch"
end
if ClientModules.EntityModules:FindFirstChild("_Shade") then
ClientModules.EntityModules:FindFirstChild("_Shade").Name = "Shade"
end
for _, prompt in ipairs(workspace.CurrentRooms:GetDescendants()) do
if prompt:IsA("ProximityPrompt") then

prompt.MaxActivationDistance = 7
prompt.HoldDuration = prompt:GetAttribute("Hold") or 7
end
end
Lighting.GlobalShadows = true
Lighting.Brightness = 0
for _, v in ipairs(workspace:GetDescendants()) do
if v:GetAttribute("HasFake") then v:SetAttribute("HasFake",nil)
end
if v:GetAttribute("Used") then
v:SetAttribute("Used",nil)
end
end

if roomConn then
roomConn:Disconnect()
roomConn = nil
end

if AutoRoomsConnection
then
AutoRoomsConnection:Disconnect()
AutoRoomsConnection = nil
end


if conn then
conn:Disconnect()
conn = nil
end
if JumpConnection then
JumpConnection:Disconnect()
JumpConnection = nil
end
if renderConn then
renderConn:Disconnect()
renderConn = nil
end
if AutoAnticheat then 
AutoAnticheat:Disconnect()
AutoAnticheat = nil
end

if con then
con:Disconnect()
con = nil
end
if Toggles.Godmode and Toggles.Godmode.Value then

LocalPlayer.Character.Collision.Position = LocalPlayer.Character.Collision.Position + Vector3.new(0, 11, 0)


end



if NewCharacter then
NewCharacter:Disconnect()
NewCharacter = nil
end



for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do


if v:FindFirstChild("HidePrompt") then

for _, base in ipairs(v:GetChildren()) do


if base:IsA("BasePart") and not (base.Name == "PlayerCollision" or base.Name == "Collision") then 


base.Transparency = 0

end


end



end



end

if oxygenNotifyConnection then
    oxygenNotifyConnection:Disconnect()
    oxygenNotifyConnection = nil
end

if oxygenHideTimer then
    oxygenHideTimer:Cancel()
    oxygenHideTimer = nil
end

if oxygenNotifyUI then
    oxygenNotifyUI:Destroy()
    oxygenNotifyUI = nil
end

oxygenNotifyRunning = false


if Toggles.HasteClock and Toggles.HasteClock.Value then
    Toggles.HasteClock:SetValue(false)
end
    
if hasteClockConnection then
    hasteClockConnection:Disconnect()
    hasteClockConnection = nil
end
    
if hasteClockRoomConnection then
    hasteClockRoomConnection:Disconnect()
    hasteClockRoomConnection = nil
end
    
if hasteClockUI then
    hasteClockUI:Destroy()
    hasteClockUI = nil
end


if NoclipConnection then
NoclipConnection:Disconnect()
NoclipConnection = nil
end
if FixingConnection then 
FixingConnection:Disconnect()
FixingConnection = nil
end
if Character:FindFirstChild("_CollisionPart") then
Character:FindFirstChild("_CollisionPart"):Destroy()
end
if Character:FindFirstChild("_CollisionPart2") then
Character:FindFirstChild("_CollisionPart2"):Destroy()
end
if SeekPath then
SeekPath:Disconnect()
SeekPath = nil
end
if AddChild then
AddChild:Disconnect()
AddChild = nil
end

for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
if v.Name == "Snare" and v.Parent and v.Parent.Name ~= "Snare" then
v:WaitForChild("Hitbox").CanTouch = false
end

end
if AutoLibraryCodeConnection then
AutoLibraryCodeConnection:Disconnect()
AutoLibraryCodeConnection = nil
end
    
if autoGlitchConnection then
autoGlitchConnection:Disconnect()
autoGlitchConnection = nil
end
autoGlitchEnabled = false
    
if Toggles.AutoGlitch and Toggles.AutoGlitch.Value then
Toggles.AutoGlitch:SetValue(false)
end

if InfiniteCrucifixConnection then
InfiniteCrucifixConnection:Disconnect()
InfiniteCrucifixConnection = nil
end

if ConInf then
ConInf:Disconnect()
ConInf = nil 
end
if PlayersConnection then
PlayersConnection:Disconnect()
PlayersConnection = nil
end

if RankedAntiBananaConnection then

RankedAntiBananaConnection:Disconnect()


RankedAntiBananaConnection = nil
end


end


CleanUp = LocalPlayer.Character.ChildAdded:Connect(function(v)

if v.Name == "Key" and ReplicatedStorage:FindFirstChild("RemotesFolder") then 

cleanupEnableReal()


end
if v.Name == "Lockpick" then

if Toggles.InfiniteItems and Toggles.InfiniteItems.Value then

scanPrompts(LockpickParents, LockpickNames)


end


if Toggles.InfiniteSItems and Toggles.InfiniteSItems.Value then

scanPrompts(ShearsParents, ShearsNames)

end




end



end)

if AnticheatManipulationLoop then
task.cancel(AnticheatManipulationLoop)
AnticheatManipulationLoop = nil
end

AnticheatManipulationEnabled = false

if alive and AnticheatManipulationOrigin then
Character:PivotTo(CFrame.new(AnticheatManipulationOrigin))
end
    
AnticheatManipulationOrigin = nil
end

LocalPlayer.CharacterAdded:Connect(function()

if CleanUp then
CleanUp:Disconnect()
CleanUp = nil
end


CleanUp = LocalPlayer.Character.ChildAdded:Connect(function(v)

if v.Name == "Key" then

cleanupEnableReal()


end
if v.Name == "Lockpick" then

if Toggles.InfiniteItems and Toggles.InfiniteItems.Value then

scanPrompts(LockpickParents, LockpickNames)


end


if Toggles.InfiniteSItems and Toggles.InfiniteSItems.Value then

scanPrompts(ShearsParents, ShearsNames)

end
end


end)


end)

SettingsBox:AddLabel("ËèúÂçï"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Âø´Êç∑ËèúÂçï" })

Library.ToggleKeybind = Options.MenuKeybind 
SettingsBox:AddToggle("ShowKeybinds", {
Text = "ÊòæÁ§∫Âø´Êç∑ÈîÆ",
Default = false,
Tooltip = "ÊòæÁ§∫Âø´Êç∑ÈîÆËèúÂçï",
}):OnChanged(function()
Library.KeybindFrame.Visible = Toggles.ShowKeybinds.Value
end)

SettingsBox:AddToggle("ShowCustomCursor", {
Text = "ÊòæÁ§∫Ëá™ÂÆö‰πâÂÖâÊ†á",
Default = Library.IsMobile == true and true or false,
Tooltip = "ÂàáÊç¢ÂÖâÊ†áÁöÑÂèØËßÅÊÄß",
}):OnChanged(function()
Library.ShowCustomCursor = Toggles.ShowCustomCursor.Value
end)

SettingsBox:AddDropdown("DPIDropdown", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "DPIÁº©Êîæ",
Callback = function(Value)
Value = Value:gsub("%%", "")
local DPI = tonumber(Value)
Library:SetDPIScale(DPI)
end,
})

SettingsBox:AddButton({
     Text = "Âç∏ËΩΩËÑöÊú¨",
     Func = function()
Unload()
end
})

local hubFolder = "Starring"
local addonFolder = hubFolder.."/Addons"

if not isfolder(hubFolder) then
makefolder(hubFolder)
end

if not isfolder(addonFolder) then
makefolder(addonFolder)
end

Starring = Starring or {}
Starring.Addons = {}

for _, file in ipairs(listfiles(addonFolder)) do
if file:sub(-4) == ".lua" or file:sub(-4) == ".txt" then
local success, addon = pcall(function()
return loadstring(readfile(file))()
end)
if success and type(addon) == "table" then
table.insert(Starring.Addons, addon)

AddonBox:AddToggle(addon.Text, {
Text = addon.Text,
Default = addon.Default,
Callback = addon.Callback
})
end

end
end


local folder_path = "Starring"
local file_path = "Doors"
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder(folder_path)
SaveManager:SetFolder(folder_path .. '/' .. file_path)


SaveManager:BuildConfigSection(Tabs['UISettings'])
ThemeManager:ApplyToTab(Tabs['UISettings'])

SaveManager:GetAutoloadConfig()
SaveManager:LoadAutoloadConfig()
SaveManager:SaveAutoloadConfig(file_path)
end
